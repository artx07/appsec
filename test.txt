#!/usr/bin/env python3
‚Äú‚Äù‚Äù
VERSI√ìN 5 COMPLETA - ChatGPT Integration con Proxy JAR stdio
Cliente MCP para Burp Suite con integraci√≥n ChatGPT usando proxy JAR con stdio
Basado en la versi√≥n 4 funcional + ChatGPT avanzado
‚Äú‚Äù‚Äù

import asyncio
import json
import logging
import subprocess
import sys
import os
import uuid
import platform
from typing import Dict, List, Optional, Any
import httpx
from datetime import datetime

# Configurar logging

logging.basicConfig(level=logging.INFO, format=‚Äô%(asctime)s - %(levelname)s - %(message)s‚Äô)
logger = logging.getLogger(**name**)

class ChatGPTClient:
‚Äú‚Äù‚ÄúCliente ChatGPT para an√°lisis de seguridad avanzado‚Äù‚Äù‚Äù

```
def __init__(self, api_key: str = None, model: str = "gpt-3.5-turbo", base_url: str = "https://api.openai.com/v1"):
    self.api_key = api_key or self._get_api_key()
    self.model = model
    self.base_url = base_url
    self.conversation_history: List[Dict] = []
    self.total_tokens_used = 0
    
    if not self.api_key:
        raise ValueError("‚ùå API key de OpenAI requerida. Config√∫rala en OPENAI_API_KEY o p√°sala como par√°metro")
    
    logger.info(f"‚úÖ ChatGPT configurado - Modelo: {self.model}")

def _get_api_key(self) -> str:
    """Obtiene la API key desde variable de entorno"""
    return os.getenv("OPENAI_API_KEY")

async def chat(self, message: str, system_prompt: str = None) -> str:
    """Chat con ChatGPT optimizado para an√°lisis de seguridad"""
    try:
        # Preparar mensajes para ChatGPT
        messages = []
        
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        
        # Agregar historial de conversaci√≥n (mantener √∫ltimos 10 intercambios para contexto)
        messages.extend(self.conversation_history[-20:])
        
        # Agregar mensaje actual del usuario
        messages.append({"role": "user", "content": message})
        
        # Llamar a la API de OpenAI
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f"{self.base_url}/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json",
                    "User-Agent": "BurpSuite-MCP-Client/5.0"
                },
                json={
                    "model": self.model,
                    "messages": messages,
                    "max_tokens": 2000,
                    "temperature": 0.7,
                    "top_p": 0.9,
                    "frequency_penalty": 0.1,
                    "presence_penalty": 0.1
                }
            )
            
            if response.status_code == 200:
                result = response.json()
                ai_response = result["choices"][0]["message"]["content"]
                
                # Tracking de uso
                usage = result.get("usage", {})
                self.total_tokens_used += usage.get("total_tokens", 0)
                
                # Guardar en historial de conversaci√≥n
                self.conversation_history.append({"role": "user", "content": message})
                self.conversation_history.append({"role": "assistant", "content": ai_response})
                
                logger.debug(f"üí∞ Tokens usados: {usage.get('total_tokens', 0)} (Total: {self.total_tokens_used})")
                
                return ai_response.strip()
            
            elif response.status_code == 401:
                return "‚ùå Error: API key inv√°lida o expirada. Verifica tu configuraci√≥n."
            elif response.status_code == 429:
                return "‚ùå Error: L√≠mite de rate exceeded. Espera un momento y vuelve a intentar."
            elif response.status_code == 400:
                error_data = response.json()
                error_msg = error_data.get("error", {}).get("message", "Error desconocido")
                return f"‚ùå Error en solicitud: {error_msg}"
            else:
                return f"‚ùå Error ChatGPT: HTTP {response.status_code} - {response.text}"
                
    except httpx.TimeoutException:
        return "‚ùå Timeout: ChatGPT tard√≥ mucho en responder. Intenta con un mensaje m√°s corto."
    except Exception as e:
        logger.error(f"Error en ChatGPT: {e}")
        return f"‚ùå Error comunicando con ChatGPT: {str(e)}"

def clear_history(self):
    """Limpia el historial de conversaci√≥n"""
    self.conversation_history = []
    logger.info("üßπ Historial de conversaci√≥n limpiado")

def get_stats(self) -> Dict:
    """Obtiene estad√≠sticas de uso"""
    return {
        "model": self.model,
        "conversation_exchanges": len(self.conversation_history) // 2,
        "total_tokens_used": self.total_tokens_used,
        "estimated_cost": self._estimate_cost()
    }

def _estimate_cost(self) -> str:
    """Estima el costo aproximado basado en tokens usados"""
    # Precios aproximados por 1K tokens (marzo 2024)
    prices = {
        "gpt-3.5-turbo": 0.002,
        "gpt-4": 0.03,
        "gpt-4-turbo": 0.01,
        "gpt-4o": 0.005
    }
    
    price_per_1k = prices.get(self.model, 0.002)
    estimated_cost = (self.total_tokens_used / 1000) * price_per_1k
    
    return f"${estimated_cost:.4f}"
```

class BurpMCPProxyClient:
‚Äú‚Äù‚ÄúCliente MCP que usa el proxy JAR con stdio (como versi√≥n 4 funcional)‚Äù‚Äù‚Äù

```
def __init__(self, host: str = "127.0.0.1", port: int = 9876):
    self.host = host
    self.port = port
    self.sse_url = f"http://{host}:{port}"
    self.proxy_jar_path = self._find_proxy_jar()
    self.java_path = self._find_java()
    self.process = None
    self.tools = {}
    self.request_counter = 0

def _find_proxy_jar(self) -> str:
    """Encuentra el proxy JAR"""
    home = os.path.expanduser("~")
    possible_paths = [
        f"{home}/.BurpSuite/mcp-proxy/mcp-proxy-all.jar",
        "/home/ron/.BurpSuite/mcp-proxy/mcp-proxy-all.jar",  # Tu ruta espec√≠fica
        "./mcp-proxy-all.jar"
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            logger.info(f"‚úÖ Proxy JAR encontrado: {path}")
            return path
    
    raise FileNotFoundError("‚ùå Proxy JAR no encontrado. Extr√°elo desde la pesta√±a MCP en Burp Suite.")

def _find_java(self) -> str:
    """Encuentra Java"""
    java_home = os.environ.get("JAVA_HOME")
    if java_home:
        java_path = os.path.join(java_home, "bin", "java")
        if os.path.exists(java_path):
            return java_path
    
    # Intentar java en PATH
    try:
        result = subprocess.run(["java", "-version"], capture_output=True, text=True)
        if result.returncode == 0:
            return "java"
    except FileNotFoundError:
        pass
    
    raise Exception("‚ùå Java no encontrado. Instala Java o configura JAVA_HOME.")

async def initialize(self) -> bool:
    """Inicializa usando proxy JAR con stdio (como versi√≥n 4)"""
    try:
        logger.info(f"üöÄ Iniciando proxy JAR: {self.proxy_jar_path}")
        logger.info(f"üåê SSE URL: {self.sse_url}")
        
        # Comando exacto como Claude Desktop
        cmd = [self.java_path, "-jar", self.proxy_jar_path, "--sse-url", self.sse_url]
        
        self.process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )
        
        # Esperar inicio
        await asyncio.sleep(3)
        
        if self.process.poll() is not None:
            stderr = self.process.stderr.read()
            logger.error(f"‚ùå Error iniciando proxy: {stderr}")
            return False
        
        # Inicializar protocolo MCP
        if await self._initialize_mcp():
            await self._load_tools()
            logger.info(f"‚úÖ Proxy inicializado con {len(self.tools)} herramientas")
            return True
        else:
            return False
            
    except Exception as e:
        logger.error(f"Error inicializando proxy: {e}")
        return False

async def _initialize_mcp(self) -> bool:
    """Inicializa protocolo MCP via stdio"""
    try:
        message = {
            "jsonrpc": "2.0",
            "id": "init",
            "method": "initialize",
            "params": {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}},
                "clientInfo": {"name": "BurpMCPClient-ChatGPT", "version": "5.0.0"}
            }
        }
        
        response = await self._send_stdio_request(message)
        return "result" in response or "error" not in response
        
    except Exception as e:
        logger.error(f"Error inicializando MCP: {e}")
        return False

async def _send_stdio_request(self, message: Dict) -> Dict:
    """Env√≠a solicitud via stdio (como versi√≥n 4)"""
    try:
        # Enviar mensaje
        json_msg = json.dumps(message) + "\n"
        self.process.stdin.write(json_msg)
        self.process.stdin.flush()
        
        # Leer respuesta
        response_line = await asyncio.wait_for(
            asyncio.to_thread(self.process.stdout.readline),
            timeout=15.0
        )
        
        if not response_line.strip():
            raise Exception("Respuesta vac√≠a del proxy")
        
        return json.loads(response_line.strip())
        
    except Exception as e:
        logger.error(f"Error en comunicaci√≥n stdio: {e}")
        return {"error": str(e)}

async def _load_tools(self):
    """Carga herramientas via stdio"""
    try:
        self.request_counter += 1
        message = {
            "jsonrpc": "2.0",
            "id": str(self.request_counter),
            "method": "tools/list",
            "params": {}
        }
        
        response = await self._send_stdio_request(message)
        
        if "result" in response and "tools" in response["result"]:
            for tool in response["result"]["tools"]:
                self.tools[tool["name"]] = tool
            logger.info(f"üìã Cargadas {len(self.tools)} herramientas via stdio")
            
            # Mostrar herramientas cargadas
            for name in self.tools.keys():
                desc = self.tools[name].get("description", "Sin descripci√≥n")
                logger.info(f"  üîß {name}: {desc[:60]}...")
        else:
            logger.warning("No se pudieron cargar herramientas via stdio")
            await self._load_default_tools()
            
    except Exception as e:
        logger.error(f"Error cargando herramientas: {e}")
        await self._load_default_tools()

async def _load_default_tools(self):
    """Carga herramientas por defecto si stdio falla"""
    default_tools = {
        "send_http1_request": "Env√≠a solicitudes HTTP/1.1 personalizadas",
        "send_http2_request": "Env√≠a solicitudes HTTP/2 personalizadas", 
        "create_repeater_tab": "Crea nueva pesta√±a en Repeater",
        "send_to_intruder": "Env√≠a solicitud a Intruder para fuzzing",
        "url_encode": "Codifica cadenas para uso en URLs",
        "url_decode": "Decodifica cadenas codificadas en URL",
        "base64_encode": "Codifica cadenas en Base64",
        "base64_decode": "Decodifica cadenas Base64",
        "generate_random_string": "Genera cadenas aleatorias",
        "get_proxy_http_history": "Obtiene historial HTTP del proxy",
        "get_proxy_http_history_regex": "Busca en historial HTTP con regex",
        "set_proxy_intercept_state": "Activa/desactiva intercepci√≥n del proxy",
        "get_scanner_issues": "Obtiene issues del scanner (Pro only)",
        "output_project_options": "Exporta configuraci√≥n del proyecto",
        "output_user_options": "Exporta configuraci√≥n del usuario"
    }
    
    logger.info("üìã Cargando herramientas por defecto (fallback)")
    for name, desc in default_tools.items():
        self.tools[name] = {"name": name, "description": desc}
        logger.info(f"  üîß {name}: {desc}")

async def call_tool(self, tool_name: str, arguments: Dict) -> str:
    """Ejecuta herramienta via stdio"""
    if tool_name not in self.tools:
        available = list(self.tools.keys())
        return f"‚ùå Herramienta '{tool_name}' no disponible.\nüìã Disponibles: {', '.join(available)}"
    
    try:
        self.request_counter += 1
        message = {
            "jsonrpc": "2.0",
            "id": str(self.request_counter),
            "method": "tools/call",
            "params": {
                "name": tool_name,
                "arguments": arguments
            }
        }
        
        logger.info(f"üîß Ejecutando: {tool_name} via stdio")
        response = await self._send_stdio_request(message)
        
        if "error" in response:
            error_details = response["error"]
            if isinstance(error_details, dict):
                error_msg = error_details.get("message", "Error desconocido")
                return f"‚ùå Error MCP: {error_msg}"
            else:
                return f"‚ùå Error: {str(error_details)}"
        
        if "result" in response:
            result = response["result"]
            
            if "content" in result and result["content"]:
                content = result["content"][0]
                text = content.get("text", str(content))
                return f"‚úÖ Resultado (stdio):\n{text}"
            
            return f"‚úÖ Resultado (stdio):\n{str(result)}"
        
        return "‚úÖ Comando ejecutado (stdio)"
        
    except Exception as e:
        logger.error(f"Error ejecutando {tool_name} via stdio: {e}")
        return f"""‚ùå Error ejecutando {tool_name}: {str(e)}
```

üîß DIAGN√ìSTICO STDIO:

- Proceso proxy activo: {‚Äò‚úÖ‚Äô if self.process and self.process.poll() is None else ‚Äò‚ùå‚Äô}
- Herramienta: {tool_name}
- Argumentos: {json.dumps(arguments, indent=2)}

üí° SUGERENCIAS:
{self._get_tool_help(tool_name)}‚Äù‚Äù‚Äù

```
def _get_tool_help(self, tool_name: str) -> str:
    """Proporciona ayuda espec√≠fica para cada herramienta"""
    help_messages = {
        "create_repeater_tab": """
```

Para create_repeater_tab necesitas:
{
‚ÄútabName‚Äù: ‚ÄúNombre de la pesta√±a‚Äù,
‚Äúcontent‚Äù: ‚ÄúGET / HTTP/1.1\r\nHost: example.com\r\n\r\n‚Äù,
‚ÄútargetHostname‚Äù: ‚Äúexample.com‚Äù,
‚ÄútargetPort‚Äù: 443,
‚ÄúusesHttps‚Äù: true
}‚Äù‚Äù‚Äù,
‚Äúsend_http1_request‚Äù: ‚Äú‚Äù‚Äù
Para send_http1_request necesitas:
{
‚Äúcontent‚Äù: ‚ÄúGET /path HTTP/1.1\r\nHost: example.com\r\n\r\n‚Äù,
‚ÄútargetHostname‚Äù: ‚Äúexample.com‚Äù,
‚ÄútargetPort‚Äù: 443,
‚ÄúusesHttps‚Äù: true
}‚Äù‚Äù‚Äù,
‚Äúsend_to_intruder‚Äù: ‚Äú‚Äù‚Äù
Para send_to_intruder necesitas:
{
‚ÄútabName‚Äù: ‚ÄúAttack Name‚Äù,
‚Äúcontent‚Äù: ‚ÄúPOST /login HTTP/1.1\r\nHost: example.com\r\n\r\nuser=admin&pass=¬ßpassword¬ß‚Äù,
‚ÄútargetHostname‚Äù: ‚Äúexample.com‚Äù,
‚ÄútargetPort‚Äù: 443,
‚ÄúusesHttps‚Äù: true
}‚Äù‚Äù‚Äù,
‚Äúget_proxy_http_history‚Äù: ‚Äú‚Äù‚Äù
Para get_proxy_http_history necesitas:
{
‚Äúcount‚Äù: 10,
‚Äúoffset‚Äù: 0
}‚Äù‚Äù‚Äù,
‚Äúurl_encode‚Äù: ‚Äú‚Äù‚Äù
Para url_encode necesitas:
{
‚Äúcontent‚Äù: ‚Äútexto a codificar‚Äù
}‚Äù‚Äù‚Äù,
‚Äúbase64_encode‚Äù: ‚Äú‚Äù‚Äù
Para base64_encode necesitas:
{
‚Äúcontent‚Äù: ‚Äútexto a codificar‚Äù
}‚Äù‚Äù‚Äù
}

```
    return help_messages.get(tool_name, f"Consulta la documentaci√≥n para {tool_name}")

async def test_connection(self) -> Dict[str, Any]:
    """Prueba la conexi√≥n del proxy stdio"""
    results = {
        "proxy_process": False,
        "stdio_communication": False,
        "tools_loaded": False,
        "error_details": []
    }
    
    # Test 1: Proceso proxy
    if self.process and self.process.poll() is None:
        results["proxy_process"] = True
    else:
        results["error_details"].append("Proceso proxy JAR no est√° ejecut√°ndose")
    
    # Test 2: Comunicaci√≥n stdio
    try:
        test_message = {
            "jsonrpc": "2.0",
            "id": "test_stdio",
            "method": "tools/list",
            "params": {}
        }
        
        response = await self._send_stdio_request(test_message)
        results["stdio_communication"] = "result" in response or "tools" in str(response)
        
        if not results["stdio_communication"]:
            results["error_details"].append(f"Comunicaci√≥n stdio fall√≥: {response}")
        
    except Exception as e:
        results["error_details"].append(f"Error comunicaci√≥n stdio: {e}")
    
    # Test 3: Herramientas cargadas
    results["tools_loaded"] = len(self.tools) > 0
    if not results["tools_loaded"]:
        results["error_details"].append("No se cargaron herramientas")
    
    return results

async def close(self):
    """Cierra el proxy"""
    if self.process:
        self.process.terminate()
        await asyncio.sleep(1)
        if self.process.poll() is None:
            self.process.kill()

def get_tools(self) -> Dict[str, str]:
    """Retorna herramientas"""
    return {name: tool.get("description", "Sin descripci√≥n") 
            for name, tool in self.tools.items()}
```

class BurpSecurityAssistantV5:
‚Äú‚Äù‚ÄúAsistente de seguridad V5 con ChatGPT usando proxy JAR stdio‚Äù‚Äù‚Äù

```
def __init__(self, burp_host="127.0.0.1", burp_port=9876, 
             openai_api_key=None, chatgpt_model="gpt-3.5-turbo"):
    # CAMBIO PRINCIPAL: Usar BurpMCPProxyClient con stdio
    self.burp = BurpMCPProxyClient(burp_host, burp_port)
    self.ai_client = ChatGPTClient(openai_api_key, chatgpt_model)
    self.system_prompt = self._create_system_prompt()
    self.session_start_time = datetime.now()

def _create_system_prompt(self) -> str:
    """Crea el prompt del sistema optimizado para ChatGPT"""
    return """Eres un experto SENIOR en seguridad web y penetration testing usando Burp Suite.
```

IMPORTANTE: Cuando el usuario solicite usar herramientas de Burp Suite, SIEMPRE debes ejecutarlas usando el formato espec√≠fico indicado m√°s abajo.

IDENTIDAD Y EXPERTISE:

- Especialista en OWASP Top 10, t√©cnicas de hacking web y an√°lisis de vulnerabilidades
- Experiencia avanzada con Burp Suite Professional y todas sus herramientas
- Conocimiento profundo de protocolos HTTP/HTTPS, t√©cnicas de bypass y evasi√≥n

REGLA CR√çTICA PARA USAR HERRAMIENTAS:
Cuando el usuario mencione cualquier acci√≥n que requiera una herramienta de Burp Suite, DEBES ejecutarla autom√°ticamente usando este formato EXACTO:

EJECUTAR_HERRAMIENTA[nombre_herramienta] {‚Äúparametro‚Äù: ‚Äúvalor‚Äù}

EJEMPLOS OBLIGATORIOS QUE DEBES SEGUIR:

1. Si el usuario dice ‚Äúbase64_encode 123‚Äù o ‚Äúencode 123 en base64‚Äù, DEBES responder:
   Voy a codificar ‚Äú123‚Äù en Base64 usando Burp Suite:
   EJECUTAR_HERRAMIENTA[base64_encode] {‚Äúcontent‚Äù: ‚Äú123‚Äù}
1. Si el usuario dice ‚Äúurl encode test‚Äù o ‚Äúcodifica test en URL‚Äù, DEBES responder:
   Voy a codificar ‚Äútest‚Äù en URL usando Burp Suite:
   EJECUTAR_HERRAMIENTA[url_encode] {‚Äúcontent‚Äù: ‚Äútest‚Äù}
1. Si el usuario dice ‚Äúcreate repeater tab with example.com‚Äù, DEBES responder:
   Voy a crear una pesta√±a en Repeater para example.com:
   EJECUTAR_HERRAMIENTA[create_repeater_tab] {‚ÄútabName‚Äù: ‚Äúexample.com Test‚Äù, ‚Äúcontent‚Äù: ‚ÄúGET / HTTP/1.1\r\nHost: example.com\r\nUser-Agent: Mozilla/5.0\r\n\r\n‚Äù, ‚ÄútargetHostname‚Äù: ‚Äúexample.com‚Äù, ‚ÄútargetPort‚Äù: 443, ‚ÄúusesHttps‚Äù: true}
1. Si el usuario dice ‚Äúget proxy history‚Äù o ‚Äúshow me the last 10 requests‚Äù, DEBES responder:
   Voy a obtener el historial del proxy:
   EJECUTAR_HERRAMIENTA[get_proxy_http_history] {‚Äúcount‚Äù: 10, ‚Äúoffset‚Äù: 0}

PAR√ÅMETROS EXACTOS REQUERIDOS:

base64_encode:

- content: string a codificar

url_encode:

- content: string a codificar

create_repeater_tab:

- tabName: ‚ÄúNombre descriptivo‚Äù
- content: ‚ÄúGET / HTTP/1.1\r\nHost: hostname\r\n\r\n‚Äù
- targetHostname: ‚Äúhostname‚Äù
- targetPort: 443 (para HTTPS) o 80 (para HTTP)
- usesHttps: true (para HTTPS) o false (para HTTP)

send_http1_request:

- content: ‚ÄúREQUEST HTTP COMPLETO con \r\n‚Äù
- targetHostname: ‚Äúhostname‚Äù
- targetPort: n√∫mero
- usesHttps: true/false

get_proxy_http_history:

- count: n√∫mero de entradas
- offset: desde qu√© posici√≥n

DETECCI√ìN AUTOM√ÅTICA:
Cuando detectes estas palabras clave en el input del usuario, EJECUTA autom√°ticamente la herramienta:

- ‚Äúbase64‚Äù, ‚Äúencode‚Äù, ‚Äúdecode‚Äù, ‚Äúcodifica‚Äù, ‚Äúdecodifica‚Äù ‚Üí usar base64_encode/base64_decode/url_encode/url_decode
- ‚Äúrepeater‚Äù, ‚Äútab‚Äù, ‚Äúcreate tab‚Äù, ‚Äúnueva pesta√±a‚Äù ‚Üí usar create_repeater_tab
- ‚Äúhistory‚Äù, ‚Äúhistorial‚Äù, ‚Äúproxy‚Äù, ‚Äúrequests‚Äù ‚Üí usar get_proxy_http_history
- ‚Äúsend request‚Äù, ‚Äúhttp request‚Äù, ‚Äúsolicitud‚Äù ‚Üí usar send_http1_request
- ‚Äúintruder‚Äù, ‚Äúattack‚Äù, ‚Äúbruteforce‚Äù ‚Üí usar send_to_intruder

IMPORTANTE:

- NUNCA escribas c√≥digo pseudo como base64_encode(‚Äú123‚Äù)
- NUNCA expliques sin ejecutar
- SIEMPRE usa el formato EJECUTAR_HERRAMIENTA[nombre] {‚Äúparams‚Äù}
- SIEMPRE incluye una breve explicaci√≥n antes de ejecutar
- Si no est√°s seguro de los par√°metros, usa valores por defecto sensatos

METODOLOG√çA:

1. Detectar qu√© herramienta necesita el usuario
1. Explicar brevemente qu√© vas a hacer
1. Ejecutar la herramienta con el formato correcto
1. Interpretar y explicar el resultado

Responde siempre como un consultor senior que EJECUTA las herramientas inmediatamente cuando se solicitan.‚Äù‚Äù‚Äù

```
async def initialize(self) -> bool:
    """Inicializa el asistente V5"""
    print("üöÄ Inicializando Asistente de Seguridad V5 (ChatGPT + stdio)...")
    
    # Conectar con Burp Suite via proxy JAR
    burp_success = await self.burp.initialize()
    if not burp_success:
        print("‚ùå No se pudo conectar con Burp Suite via proxy JAR")
        return False
    
    # Verificar ChatGPT
    try:
        test_response = await self.ai_client.chat(
            "Responde solo 'READY' para confirmar conexi√≥n", 
            "Eres un asistente de prueba. Responde exactamente lo que se te pide."
        )
        if "READY" in test_response.upper():
            print("‚úÖ ChatGPT conectado correctamente")
            print(f"ü§ñ Modelo: {self.ai_client.model}")
        else:
            print("‚ö†Ô∏è ChatGPT responde pero puede tener problemas")
    except Exception as e:
        print(f"‚ùå No se pudo conectar con ChatGPT: {e}")
        return False
    
    # Actualizar prompt con herramientas disponibles
    tools_info = "\n".join([f"- {name}: {desc}" 
                           for name, desc in self.burp.get_tools().items()])
    self.system_prompt += f"\n\nHERRAMIENTAS DISPONIBLES EN BURP SUITE:\n{tools_info}"
    
    # ENTRENAR A CHATGPT CON EJEMPLOS
    print("üß† Entrenando ChatGPT con ejemplos de herramientas...")
    await self._train_chatgpt_with_examples()
    
    print(f"üìä {len(self.burp.get_tools())} herramientas cargadas via stdio")
    return True

async def _train_chatgpt_with_examples(self):
    """Entrena a ChatGPT con ejemplos de c√≥mo usar las herramientas"""
    training_examples = [
        {
            "user": "base64_encode test123",
            "assistant": "Voy a codificar 'test123' en Base64 usando Burp Suite:\nEJECUTAR_HERRAMIENTA[base64_encode] {\"content\": \"test123\"}"
        },
        {
            "user": "url encode <script>alert(1)</script>",
            "assistant": "Voy a codificar el script en URL usando Burp Suite:\nEJECUTAR_HERRAMIENTA[url_encode] {\"content\": \"<script>alert(1)</script>\"}"
        },
        {
            "user": "create repeater tab for example.com",
            "assistant": "Voy a crear una pesta√±a en Repeater para example.com:\nEJECUTAR_HERRAMIENTA[create_repeater_tab] {\"tabName\": \"example.com Test\", \"content\": \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\nUser-Agent: Mozilla/5.0\\r\\n\\r\\n\", \"targetHostname\": \"example.com\", \"targetPort\": 443, \"usesHttps\": true}"
        }
    ]
    
    # Agregar ejemplos al historial para que ChatGPT aprenda
    for example in training_examples:
        self.ai_client.conversation_history.append({"role": "user", "content": example["user"]})
        self.ai_client.conversation_history.append({"role": "assistant", "content": example["assistant"]})
    
    print("‚úÖ ChatGPT entrenado con ejemplos de herramientas")

async def process_message(self, user_message: str) -> str:
    """Procesa mensaje del usuario con ChatGPT"""
    try:
        # Obtener respuesta de ChatGPT
        ai_response = await self.ai_client.chat(user_message, self.system_prompt)
        
        # Ejecutar herramientas si se mencionan
        if "EJECUTAR_HERRAMIENTA[" in ai_response:
            ai_response = await self._execute_tools(ai_response)
        
        return ai_response
        
    except Exception as e:
        logger.error(f"Error procesando mensaje: {e}")
        return f"‚ùå Error procesando mensaje: {str(e)}"

async def _execute_tools(self, response: str) -> str:
    """Ejecuta herramientas mencionadas en la respuesta de ChatGPT"""
    import re
    
    # Buscar patrones EJECUTAR_HERRAMIENTA[nombre]
    pattern = r'EJECUTAR_HERRAMIENTA\[([^\]]+)\]'
    matches = re.finditer(pattern, response)
    
    for match in matches:
        tool_name = match.group(1).strip()
        
        # Buscar argumentos JSON despu√©s del comando
        json_pattern = r'\{[^}]+\}'
        text_after_match = response[match.end():match.end()+500]
        json_match = re.search(json_pattern, text_after_match)
        
        if json_match:
            try:
                arguments = json.loads(json_match.group(0))
            except json.JSONDecodeError as e:
                arguments = {}
                logger.warning(f"Error parsing JSON para {tool_name}: {e}")
        else:
            arguments = {}
        
        # Ejecutar herramienta via stdio
        result = await self.burp.call_tool(tool_name, arguments)
        
        # Reemplazar comando con resultado
        replacement = f"\n\n**üîß Ejecutando {tool_name} (stdio):**\n```\n{result}\n```\n"
        response = response.replace(match.group(0), replacement, 1)
    
    return response

async def chat_loop(self):
    """Loop principal de chat V5"""
    print("\n" + "="*70)
    print("üîí ASISTENTE DE SEGURIDAD V5 - Burp Suite + ChatGPT (stdio)")
    print("="*70)
    print("Comandos especiales:")
    print("  /tools     - Ver herramientas disponibles")
    print("  /diagnose  - Diagnosticar problemas de conexi√≥n stdio")
    print("  /stats     - Ver estad√≠sticas de ChatGPT")
    print("  /clear     - Limpiar historial y re-entrenar")
    print("  /train     - Re-entrenar ChatGPT con ejemplos")
    print("  /model     - Cambiar modelo de ChatGPT")
    print("  /examples  - Ver ejemplos avanzados")
    print("  /save      - Guardar sesi√≥n")
    print("  /help      - Mostrar ayuda")
    print("  /quit      - Salir")
    print("="*70)
    
    command_history = []
    
    while True:
        try:
            user_input = input("\nüë§ T√∫: ").strip()
            
            if user_input.lower() in ['/quit', '/exit']:
                await self._show_session_summary()
                print("üëã ¬°Hasta luego!")
                break
            
            elif user_input.lower() == '/tools':
                tools = self.burp.get_tools()
                print(f"\nüõ†Ô∏è Herramientas disponibles ({len(tools)}):")
                for name, desc in tools.items():
                    print(f"  üîß {name}: {desc}")
                continue
            
            elif user_input.lower() == '/diagnose':
                print("\nüîç Ejecutando diagn√≥stico de conexi√≥n stdio...")
                diagnosis = await self.burp.test_connection()
                
                print("\nüìä RESULTADOS DEL DIAGN√ìSTICO (STDIO):")
                print(f"üîß Proceso proxy JAR: {'‚úÖ' if diagnosis['proxy_process'] else '‚ùå'}")
                print(f"üì° Comunicaci√≥n stdio: {'‚úÖ' if diagnosis['stdio_communication'] else '‚ùå'}")
                print(f"üõ†Ô∏è Herramientas cargadas: {'‚úÖ' if diagnosis['tools_loaded'] else '‚ùå'}")
                
                if diagnosis['error_details']:
                    print("\n‚ùå ERRORES DETECTADOS:")
                    for error in diagnosis['error_details']:
                        print(f"  ‚Ä¢ {error}")
                    
                    print("\nüîß SOLUCIONES ESPEC√çFICAS PARA STDIO:")
                    print("1. Verificar que el proxy JAR existe:")
                    print(f"   ls -la {self.burp.proxy_jar_path}")
                    print()
                    print("2. Verificar que Burp Suite est√© ejecut√°ndose:")
                    print("   ps aux | grep -i burp")
                    print()
                    print("3. Verificar que el servidor SSE est√© activo en Burp:")
                    print(f"   curl http://{self.burp.host}:{self.burp.port}")
                    print()
                    print("4. Extraer proxy JAR desde Burp Suite:")
                    print("   - Ve a la pesta√±a MCP en Burp Suite")
                    print("   - Click en 'Extract server proxy jar'")
                    print(f"   - Guardar en: {self.burp.proxy_jar_path}")
                    print()
                    print("5. Verificar Java:")
                    print(f"   {self.burp.java_path} -version")
                    print()
                    print("6. Reiniciar manualmente el proxy:")
                    print(f"   {self.burp.java_path} -jar {self.burp.proxy_jar_path} --sse-url {self.burp.sse_url}")
                else:
                    print("\n‚úÖ Comunicaci√≥n stdio funcionando correctamente")
                    print(f"üìÇ Proxy JAR: {self.burp.proxy_jar_path}")
                    print(f"‚òï Java: {self.burp.java_path}")
                    print(f"üåê SSE URL: {self.burp.sse_url}")
                
                continue
            
            elif user_input.lower() == '/stats':
                stats = self.ai_client.get_stats()
                print(f"\nüìä Estad√≠sticas de ChatGPT:")
                print(f"  ü§ñ Modelo: {stats['model']}")
                print(f"  üí¨ Intercambios: {stats['conversation_exchanges']}")
                print(f"  üéØ Tokens usados: {stats['total_tokens_used']}")
                print(f"  üí∞ Costo estimado: {stats['estimated_cost']}")
                continue
            
            elif user_input.lower() == '/clear':
                self.ai_client.clear_history()
                # Re-entrenar despu√©s de limpiar
                await self._train_chatgpt_with_examples()
                print("üßπ Historial limpiado y ChatGPT re-entrenado con ejemplos")
                continue
            
            elif user_input.lower() == '/train':
                print("üß† Re-entrenando ChatGPT con ejemplos...")
                await self._train_chatgpt_with_examples()
                print("‚úÖ ChatGPT re-entrenado correctamente")
                continue
            
            elif user_input.lower() == '/model':
                print("\nü§ñ Modelos disponibles:")
                models = ["gpt-3.5-turbo", "gpt-4", "gpt-4-turbo", "gpt-4o"]
                for i, model in enumerate(models, 1):
                    current = " (actual)" if model == self.ai_client.model else ""
                    print(f"  {i}. {model}{current}")
                
                try:
                    choice = int(input("Selecciona modelo (1-4): ")) - 1
                    if 0 <= choice < len(models):
                        self.ai_client.model = models[choice]
                        print(f"‚úÖ Modelo cambiado a: {models[choice]}")
                    else:
                        print("‚ùå Opci√≥n inv√°lida")
                except ValueError:
                    print("‚ùå Entrada inv√°lida")
                continue
            
            elif user_input.lower() == '/examples':
                print(self._show_advanced_examples())
                continue
            
            elif user_input.lower() == '/save':
                await self._save_session_v5(command_history)
                continue
            
            elif user_input.lower() == '/help':
                print(self._show_help_v5())
                continue
            
            elif not user_input:
                continue
            
            # Agregar a historial
            command_history.append({
                "timestamp": datetime.now().isoformat(),
                "message": user_input
            })
            
            print("\nü§ñ Asistente: ", end="", flush=True)
            response = await self.process_message(user_input)
            print(response)
            
        except KeyboardInterrupt:
            print("\n\nüëã Saliendo...")
            break
        except Exception as e:
            print(f"\n‚ùå Error: {e}")

def _show_advanced_examples(self) -> str:
    """Muestra ejemplos avanzados para ChatGPT"""
    return """
```

üéì EJEMPLOS AVANZADOS DE SECURITY TESTING:

üîç RECONOCIMIENTO Y AN√ÅLISIS:
‚Ä¢ ‚ÄúAnaliza las √∫ltimas 20 entradas del historial HTTP en busca de endpoints de API REST y eval√∫a su superficie de ataque‚Äù
‚Ä¢ ‚ÄúIdentifica todos los par√°metros GET y POST √∫nicos del historial y sugiere vectores de ataque para cada uno‚Äù
‚Ä¢ ‚ÄúExamina los headers de respuesta del historial para identificar tecnolog√≠as, versiones y configuraciones inseguras‚Äù

‚ö° TESTING DE VULNERABILIDADES ESPEC√çFICAS:
‚Ä¢ ‚ÄúPrueba SQL injection en el par√°metro ‚Äòid‚Äô del endpoint /api/users usando t√©cnicas de boolean-based blind injection‚Äù
‚Ä¢ ‚ÄúCrea un payload XSS que bypassee filtros de Content Security Policy para el formulario de comentarios‚Äù
‚Ä¢ ‚ÄúAnaliza el mecanismo de autenticaci√≥n JWT y busca vulnerabilidades de signature bypass‚Äù

üõ°Ô∏è EVALUACI√ìN DE CONTROLES DE SEGURIDAD:
‚Ä¢ ‚ÄúEval√∫a la implementaci√≥n de CSRF protection en todos los formularios POST encontrados en el historial‚Äù
‚Ä¢ ‚ÄúAnaliza la configuraci√≥n de cookies de sesi√≥n y identifica problemas de seguridad (secure, httponly, samesite)‚Äù
‚Ä¢ ‚ÄúRevisa la implementaci√≥n de rate limiting y sugiere t√©cnicas de bypass‚Äù

üîê AN√ÅLISIS DE L√ìGICA DE NEGOCIO:
‚Ä¢ ‚ÄúIdentifica flujos de autorizaci√≥n en la aplicaci√≥n y busca vulnerabilities de privilege escalation‚Äù
‚Ä¢ ‚ÄúAnaliza el proceso de reset de password en busca de race conditions y logic flaws‚Äù
‚Ä¢ ‚ÄúEval√∫a el manejo de archivos upload y identifica vectores de ataque para file inclusion‚Äù

üö® TESTING AVANZADO:
‚Ä¢ ‚ÄúRealiza un an√°lisis completo de CORS configuration y identifica misconfigurations explotables‚Äù
‚Ä¢ ‚ÄúEval√∫a la aplicaci√≥n contra OWASP Top 10 2021 y genera un reporte de hallazgos prioritizado‚Äù
‚Ä¢ ‚ÄúCrea un plan de testing personalizado basado en las tecnolog√≠as identificadas en el reconocimiento‚Äù

üîß EJEMPLOS CON HERRAMIENTAS ESPEC√çFICAS:
‚Ä¢ ‚ÄúCrea una pesta√±a en Repeater para secure.ally.com puerto 443 con una solicitud GET b√°sica‚Äù
‚Ä¢ ‚ÄúEnv√≠a a Intruder una solicitud de login con el usuario ‚Äòadmin‚Äô para hacer bruteforce de password‚Äù
‚Ä¢ ‚ÄúEncode en URL el payload: ‚Äô OR 1=1 UNION SELECT username,password FROM users‚Äì‚Äù
‚Äú‚Äù‚Äù

```
async def _save_session_v5(self, command_history):
    """Guarda sesi√≥n V5 con estad√≠sticas de ChatGPT"""
    try:
        stats = self.ai_client.get_stats()
        session_data = {
            "version": "5.0-stdio",
            "timestamp": datetime.now().isoformat(),
            "session_duration": str(datetime.now() - self.session_start_time),
            "commands": command_history,
            "burp_tools": list(self.burp.get_tools().keys()),
            "chatgpt_stats": stats,
            "proxy_info": {
                "jar_path": self.burp.proxy_jar_path,
                "java_path": self.burp.java_path,
                "sse_url": self.burp.sse_url,
                "communication_method": "stdio"
            },
            "system_info": {
                "platform": platform.system(),
                "python_version": sys.version,
                "burp_host": self.burp.host,
                "burp_port": self.burp.port
            }
        }
        
        filename = f"burp_chatgpt_v5_session_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(filename, 'w') as f:
            json.dump(session_data, f, indent=2)
        
        print(f"‚úÖ Sesi√≥n V5 guardada en: {filename}")
        print(f"üìä Resumen: {len(command_history)} comandos, {stats['total_tokens_used']} tokens, {stats['estimated_cost']} costo")
        
    except Exception as e:
        print(f"‚ùå Error guardando sesi√≥n: {e}")

async def _show_session_summary(self):
    """Muestra resumen de la sesi√≥n"""
    stats = self.ai_client.get_stats()
    duration = datetime.now() - self.session_start_time
    
    print("\n" + "="*50)
    print("üìä RESUMEN DE SESI√ìN V5")
    print("="*50)
    print(f"‚è±Ô∏è  Duraci√≥n: {duration}")
    print(f"ü§ñ Modelo usado: {stats['model']}")
    print(f"üí¨ Intercambios: {stats['conversation_exchanges']}")
    print(f"üéØ Tokens totales: {stats['total_tokens_used']}")
    print(f"üí∞ Costo estimado: {stats['estimated_cost']}")
    print(f"üîß Herramientas disponibles: {len(self.burp.get_tools())}")
    print(f"üì° M√©todo de comunicaci√≥n: stdio")

def _show_help_v5(self) -> str:
    """Ayuda completa V5"""
    stats = self.ai_client.get_stats()
    return f"""
```

üìñ AYUDA COMPLETA - Asistente de Seguridad V5 (ChatGPT + stdio)

üéØ NOVEDADES DE LA VERSI√ìN 5:
‚úÖ Integraci√≥n completa con ChatGPT (GPT-3.5-turbo, GPT-4, GPT-4-turbo)
‚úÖ Comunicaci√≥n robusta via proxy JAR con stdio (como versi√≥n 4)
‚úÖ An√°lisis de seguridad con IA de nivel profesional
‚úÖ Tracking de costos y tokens en tiempo real
‚úÖ Prompt especializado en penetration testing
‚úÖ Capacidad de cambio de modelo din√°mico
‚úÖ Estad√≠sticas detalladas de uso
‚úÖ Diagn√≥stico espec√≠fico para comunicaci√≥n stdio

üîß CONFIGURACI√ìN ACTUAL:
‚Ä¢ Burp Suite: Conectado via proxy JAR + stdio
‚Ä¢ ChatGPT: {self.ai_client.model} - {stats[‚Äòconversation_exchanges‚Äô]} intercambios
‚Ä¢ Herramientas: {len(self.burp.get_tools())} disponibles
‚Ä¢ Proxy JAR: {self.burp.proxy_jar_path}
‚Ä¢ Java: {self.burp.java_path}
‚Ä¢ SSE URL: {self.burp.sse_url}
‚Ä¢ Sesi√≥n iniciada: {self.session_start_time.strftime(‚Äô%H:%M:%S‚Äô)}

üí¨ C√ìMO INTERACTUAR:
‚Ä¢ Habla en lenguaje natural sobre cualquier aspecto de seguridad web
‚Ä¢ ChatGPT identificar√° autom√°ticamente las herramientas necesarias
‚Ä¢ Proporciona contexto t√©cnico detallado para mejores an√°lisis
‚Ä¢ Pregunta sobre vulnerabilidades espec√≠ficas, metodolog√≠as, etc.

üéì CAPACIDADES AVANZADAS DE CHATGPT:
‚Ä¢ An√°lisis contextual profundo de vulnerabilidades
‚Ä¢ Generaci√≥n de payloads espec√≠ficos y personalizados
‚Ä¢ Interpretaci√≥n inteligente de resultados de herramientas
‚Ä¢ Correlaci√≥n de hallazgos entre m√∫ltiples requests/responses
‚Ä¢ Sugerencias de t√©cnicas de evasi√≥n y bypass
‚Ä¢ Evaluaci√≥n de impacto y priorizaci√≥n de vulnerabilidades

üõ†Ô∏è HERRAMIENTAS PRINCIPALES (via stdio):
‚Ä¢ send_http1_request: Solicitudes HTTP personalizadas
‚Ä¢ get_proxy_http_history: An√°lisis de tr√°fico hist√≥rico
‚Ä¢ create_repeater_tab: Integraci√≥n con Repeater
‚Ä¢ send_to_intruder: Setup de ataques automatizados
‚Ä¢ url_encode/decode: Codificaci√≥n para bypasses
‚Ä¢ base64_encode/decode: Codificaci√≥n de payloads

üí∞ GESTI√ìN DE COSTOS:
‚Ä¢ Usa /stats para monitorear gasto en tiempo real
‚Ä¢ GPT-3.5-turbo: ~$0.002/1K tokens (econ√≥mico)
‚Ä¢ GPT-4-turbo: ~$0.01/1K tokens (equilibrado)
‚Ä¢ GPT-4: ~$0.03/1K tokens (m√°xima calidad)

üöÄ TIPS PARA MEJORES RESULTADOS:
‚Ä¢ S√© espec√≠fico sobre el tipo de vulnerabilidad que buscas
‚Ä¢ Proporciona contexto sobre la aplicaci√≥n target
‚Ä¢ Menciona tecnolog√≠as conocidas (framework, server, etc.)
‚Ä¢ Pide explicaciones detalladas de t√©cnicas complejas
‚Ä¢ Solicita m√∫ltiples vectores de ataque para un mismo objetivo

‚ö†Ô∏è CONSIDERACIONES DE SEGURIDAD:
‚Ä¢ No env√≠es datos sensibles reales a ChatGPT
‚Ä¢ Usa datos de prueba o sanitizados para examples
‚Ä¢ Recuerda que ChatGPT almacena conversaciones temporalmente
‚Ä¢ Para m√°xima privacidad, considera usar modelos locales (Ollama)

üîÑ COMANDOS ESPECIALES:
/tools - Ver herramientas de Burp disponibles
/diagnose - Diagn√≥stico de comunicaci√≥n stdio
/stats - Estad√≠sticas de uso y costos de ChatGPT
/model - Cambiar entre modelos de ChatGPT
/clear - Limpiar historial de conversaci√≥n
/save - Guardar sesi√≥n completa con estad√≠sticas

üîß VENTAJAS DE LA COMUNICACI√ìN STDIO:
‚úÖ M√©todo probado y estable (igual que Claude Desktop)
‚úÖ No depende de endpoints HTTP espec√≠ficos
‚úÖ Comunicaci√≥n bidireccional confiable
‚úÖ Compatible con todas las herramientas MCP de Burp
‚úÖ Manejo robusto de errores y timeouts
‚Äú‚Äù‚Äù

```
async def close(self):
    """Cierra conexiones V5"""
    await self.burp.close()
```

def setup_chatgpt_v5():
‚Äú‚Äù‚ÄúConfiguraci√≥n de ChatGPT para V5‚Äù‚Äù‚Äù
print(‚Äúüîß CONFIGURACI√ìN CHATGPT V5‚Äù)
print(‚Äù=‚Äù * 50)

```
# Verificar API key existente
api_key = os.getenv("OPENAI_API_KEY")

if api_key:
    # Validar formato de API key
    if api_key.startswith("sk-") and len(api_key) > 20:
        print(f"‚úÖ API key encontrada: {api_key[:8]}...{api_key[-8:]}")
        return api_key
    else:
        print("‚ö†Ô∏è API key encontrada pero formato inv√°lido")

print("‚ùå API key no configurada o inv√°lida")
print("\nüìã OPCIONES DE CONFIGURACI√ìN:")
print("1. Configurar variable de entorno (recomendado)")
print("2. Ingreso directo (temporal)")
print("3. Archivo de configuraci√≥n")

while True:
    choice = input("\nSelecciona opci√≥n (1-3): ").strip()
    
    if choice == "1":
        api_key = input("\nüîë Ingresa tu API key de OpenAI: ").strip()
        if not api_key.startswith("sk-"):
            print("‚ùå Formato de API key inv√°lido. Debe empezar con 'sk-'")
            continue
        
        print(f"\nüìù CONFIGURACI√ìN PERMANENTE:")
        print("Agrega esta l√≠nea a tu ~/.bashrc, ~/.zshrc o ~/.profile:")
        print(f"export OPENAI_API_KEY='{api_key}'")
        print("\nLuego ejecuta: source ~/.bashrc (o el archivo correspondiente)")
        
        # Configurar temporalmente para esta sesi√≥n
        os.environ["OPENAI_API_KEY"] = api_key
        return api_key
    
    elif choice == "2":
        api_key = input("\nüîë Ingresa tu API key de OpenAI: ").strip()
        if not api_key.startswith("sk-"):
            print("‚ùå Formato de API key inv√°lido. Debe empezar con 'sk-'")
            continue
        print("‚ö†Ô∏è Esta configuraci√≥n es temporal (solo para esta sesi√≥n)")
        return api_key
    
    elif choice == "3":
        api_key = input("\nüîë Ingresa tu API key de OpenAI: ").strip()
        if not api_key.startswith("sk-"):
            print("‚ùå Formato de API key inv√°lido. Debe empezar con 'sk-'")
            continue
        
        try:
            config_file = "chatgpt_config.json"
            config_data = {"openai_api_key": api_key}
            with open(config_file, 'w') as f:
                json.dump(config_data, f, indent=2)
            print(f"‚úÖ Configuraci√≥n guardada en: {config_file}")
            print("‚ö†Ô∏è IMPORTANTE: Agrega este archivo a .gitignore para seguridad")
            return api_key
        except Exception as e:
            print(f"‚ùå Error guardando configuraci√≥n: {e}")
            continue
    
    else:
        print("‚ùå Opci√≥n inv√°lida. Selecciona 1, 2 o 3.")
```

def load_config_file():
‚Äú‚Äù‚ÄúCarga configuraci√≥n desde archivo si existe‚Äù‚Äù‚Äù
try:
with open(‚Äúchatgpt_config.json‚Äù, ‚Äòr‚Äô) as f:
config = json.load(f)
return config.get(‚Äúopenai_api_key‚Äù)
except FileNotFoundError:
return None
except Exception as e:
logger.warning(f‚ÄùError cargando configuraci√≥n: {e}‚Äù)
return None

def show_model_comparison_v5():
‚Äú‚Äù‚ÄúMuestra comparaci√≥n detallada de modelos ChatGPT‚Äù‚Äù‚Äù
print(‚Äù\nü§ñ COMPARACI√ìN DE MODELOS CHATGPT‚Äù)
print(‚Äù=‚Äù * 60)

```
models = {
    "gpt-3.5-turbo": {
        "Costo": "~$0.002/1K tokens",
        "Velocidad": "Muy r√°pido (1-3 seg)",
        "Calidad": "Buena para tareas generales",
        "Contexto": "16K tokens",
        "Recomendado para": "Uso general, an√°lisis b√°sicos"
    },
    "gpt-4": {
        "Costo": "~$0.03/1K tokens", 
        "Velocidad": "Lento (10-30 seg)",
        "Calidad": "Excelente para an√°lisis complejos",
        "Contexto": "8K tokens",
        "Recomendado para": "An√°lisis cr√≠ticos, vulnerabilidades complejas"
    },
    "gpt-4-turbo": {
        "Costo": "~$0.01/1K tokens",
        "Velocidad": "Medio (3-8 seg)", 
        "Calidad": "Muy buena, equilibrada",
        "Contexto": "128K tokens",
        "Recomendado para": "Equilibrio perfecto precio/calidad"
    },
    "gpt-4o": {
        "Costo": "~$0.005/1K tokens",
        "Velocidad": "R√°pido (2-5 seg)",
        "Calidad": "Excelente para multimodal",
        "Contexto": "128K tokens", 
        "Recomendado para": "An√°lisis de im√°genes, docs complejos"
    }
}

for model, specs in models.items():
    print(f"\nüìä {model.upper()}:")
    for spec, value in specs.items():
        print(f"  {spec}: {value}")

print(f"\nüí° RECOMENDACI√ìN PARA SEGURIDAD:")
print("‚Ä¢ Desarrollo/Testing: gpt-3.5-turbo")
print("‚Ä¢ An√°lisis profesional: gpt-4-turbo") 
print("‚Ä¢ Casos cr√≠ticos: gpt-4")
```

async def test_chatgpt_connection(api_key: str, model: str = ‚Äúgpt-3.5-turbo‚Äù):
‚Äú‚Äù‚ÄúPrueba la conexi√≥n con ChatGPT‚Äù‚Äù‚Äù
print(f‚Äù\nüß™ PROBANDO CONEXI√ìN CON CHATGPT ({model})‚Äù)
print(‚Äù=‚Äù * 50)

```
try:
    client = ChatGPTClient(api_key, model)
    
    # Test b√°sico
    print("üì° Enviando mensaje de prueba...")
    response = await client.chat(
        "Responde exactamente 'CONEXION_OK' para confirmar que funciona",
        "Eres un bot de prueba. Responde exactamente lo solicitado."
    )
    
    if "CONEXION_OK" in response:
        print("‚úÖ Conexi√≥n exitosa")
        
        # Test de capacidades de seguridad
        print("üîí Probando capacidades de seguridad...")
        security_response = await client.chat(
            "Lista 3 vulnerabilidades web comunes en una l√≠nea separadas por comas",
            "Eres un experto en seguridad web."
        )
        
        print(f"üõ°Ô∏è Respuesta de seguridad: {security_response[:100]}...")
        
        # Mostrar estad√≠sticas
        stats = client.get_stats()
        print(f"üìä Tokens usados: {stats['total_tokens_used']}")
        print(f"üí∞ Costo estimado: {stats['estimated_cost']}")
        
        return True
    else:
        print(f"‚ùå Respuesta inesperada: {response}")
        return False
        
except Exception as e:
    print(f"‚ùå Error en conexi√≥n: {e}")
    return False
```

async def main():
‚Äú‚Äù‚ÄúFunci√≥n principal V5‚Äù‚Äù‚Äù
print(‚ÄúüöÄ ASISTENTE DE SEGURIDAD V5 - CHATGPT + STDIO INTEGRATION‚Äù)
print(‚Äù=‚Äù * 70)
print(‚ÄúVersi√≥n 5.0 - ChatGPT + Proxy JAR con comunicaci√≥n stdio‚Äù)
print(‚ÄúM√©todo probado y estable igual que Claude Desktop‚Äù)
print()

```
# Configurar ChatGPT
api_key = load_config_file() or setup_chatgpt_v5()
if not api_key:
    print("‚ùå No se pudo configurar ChatGPT")
    return

# Mostrar opciones de modelo
show_model_comparison_v5()
print(f"\nü§ñ Modelo por defecto: gpt-3.5-turbo")

change_model = input("¬øQuieres cambiar el modelo? (y/N): ").strip().lower()
model = "gpt-3.5-turbo"

if change_model == 'y':
    models = ["gpt-3.5-turbo", "gpt-4-turbo", "gpt-4", "gpt-4o"]
    print("\nModelos disponibles:")
    for i, m in enumerate(models, 1):
        print(f"  {i}. {m}")
    
    try:
        choice = int(input("Selecciona (1-4): ")) - 1
        if 0 <= choice < len(models):
            model = models[choice]
            print(f"‚úÖ Modelo seleccionado: {model}")
        else:
            print("‚ùå Opci√≥n inv√°lida, usando gpt-3.5-turbo")
    except ValueError:
        print("‚ùå Entrada inv√°lida, usando gpt-3.5-turbo")

# Probar conexi√≥n
if not await test_chatgpt_connection(api_key, model):
    print("‚ùå No se pudo establecer conexi√≥n con ChatGPT")
    return

# Crear e inicializar asistente
assistant = BurpSecurityAssistantV5(openai_api_key=api_key, chatgpt_model=model)

try:
    if await assistant.initialize():
        print(f"\nüéâ ¬°Asistente V5 listo!")
        print(f"üîß Burp Suite: Conectado via proxy JAR + stdio")
        print(f"ü§ñ ChatGPT: {model}")
        print(f"üìä Herramientas: {len(assistant.burp.get_tools())}")
        print(f"üìÇ Proxy JAR: {assistant.burp.proxy_jar_path}")
        await assistant.chat_loop()
    else:
        print("\n‚ùå ERROR DE CONFIGURACI√ìN")
        print("\nVerifica que:")
        print("1. Burp Suite est√© ejecut√°ndose")
        print("2. La extensi√≥n MCP est√© instalada y habilitada") 
        print("3. El proxy JAR est√© extra√≠do y disponible")
        print("4. Java est√© instalado y disponible")
        print("5. Tu API key de OpenAI sea v√°lida")
        print("6. Tengas cr√©ditos disponibles en OpenAI")
        print("7. El servidor SSE est√© corriendo en Burp (puerto 9876)")

finally:
    await assistant.close()
```

if **name** == ‚Äú**main**‚Äù:
try:
asyncio.run(main())
except KeyboardInterrupt:
print(‚Äù\nüëã Programa terminado por el usuario‚Äù)
except Exception as e:
print(f‚Äù\n‚ùå Error fatal: {e}‚Äù)
logger.error(f‚ÄùError fatal: {e}‚Äù)
sys.exit(1)