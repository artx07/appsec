#!/usr/bin/env python3
â€œâ€â€
VERSIÃ“N 5 COMPLETA - ChatGPT Integration con Proxy JAR stdio
Cliente MCP para Burp Suite con integraciÃ³n ChatGPT usando proxy JAR con stdio
Basado en la versiÃ³n 4 funcional + ChatGPT avanzado
â€œâ€â€

import asyncio
import json
import logging
import subprocess
import sys
import os
import uuid
import platform
from typing import Dict, List, Optional, Any
import httpx
from datetime import datetime

# Configurar logging

logging.basicConfig(level=logging.INFO, format=â€™%(asctime)s - %(levelname)s - %(message)sâ€™)
logger = logging.getLogger(**name**)

class ChatGPTClient:
â€œâ€â€œCliente ChatGPT para anÃ¡lisis de seguridad avanzadoâ€â€â€

```
def __init__(self, api_key: str = None, model: str = "gpt-3.5-turbo", base_url: str = "https://api.openai.com/v1"):
    self.api_key = api_key or self._get_api_key()
    self.model = model
    self.base_url = base_url
    self.conversation_history: List[Dict] = []
    self.total_tokens_used = 0
    
    if not self.api_key:
        raise ValueError("âŒ API key de OpenAI requerida. ConfigÃºrala en OPENAI_API_KEY o pÃ¡sala como parÃ¡metro")
    
    logger.info(f"âœ… ChatGPT configurado - Modelo: {self.model}")

def _get_api_key(self) -> str:
    """Obtiene la API key desde variable de entorno"""
    return os.getenv("OPENAI_API_KEY")

async def chat(self, message: str, system_prompt: str = None) -> str:
    """Chat con ChatGPT optimizado para anÃ¡lisis de seguridad"""
    try:
        # Preparar mensajes para ChatGPT
        messages = []
        
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        
        # Agregar historial de conversaciÃ³n (mantener Ãºltimos 10 intercambios para contexto)
        messages.extend(self.conversation_history[-20:])
        
        # Agregar mensaje actual del usuario
        messages.append({"role": "user", "content": message})
        
        # Llamar a la API de OpenAI
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f"{self.base_url}/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json",
                    "User-Agent": "BurpSuite-MCP-Client/5.0"
                },
                json={
                    "model": self.model,
                    "messages": messages,
                    "max_tokens": 2000,
                    "temperature": 0.7,
                    "top_p": 0.9,
                    "frequency_penalty": 0.1,
                    "presence_penalty": 0.1
                }
            )
            
            if response.status_code == 200:
                result = response.json()
                ai_response = result["choices"][0]["message"]["content"]
                
                # Tracking de uso
                usage = result.get("usage", {})
                self.total_tokens_used += usage.get("total_tokens", 0)
                
                # Guardar en historial de conversaciÃ³n
                self.conversation_history.append({"role": "user", "content": message})
                self.conversation_history.append({"role": "assistant", "content": ai_response})
                
                logger.debug(f"ğŸ’° Tokens usados: {usage.get('total_tokens', 0)} (Total: {self.total_tokens_used})")
                
                return ai_response.strip()
            
            elif response.status_code == 401:
                return "âŒ Error: API key invÃ¡lida o expirada. Verifica tu configuraciÃ³n."
            elif response.status_code == 429:
                return "âŒ Error: LÃ­mite de rate exceeded. Espera un momento y vuelve a intentar."
            elif response.status_code == 400:
                error_data = response.json()
                error_msg = error_data.get("error", {}).get("message", "Error desconocido")
                return f"âŒ Error en solicitud: {error_msg}"
            else:
                return f"âŒ Error ChatGPT: HTTP {response.status_code} - {response.text}"
                
    except httpx.TimeoutException:
        return "âŒ Timeout: ChatGPT tardÃ³ mucho en responder. Intenta con un mensaje mÃ¡s corto."
    except Exception as e:
        logger.error(f"Error en ChatGPT: {e}")
        return f"âŒ Error comunicando con ChatGPT: {str(e)}"

def clear_history(self):
    """Limpia el historial de conversaciÃ³n"""
    self.conversation_history = []
    logger.info("ğŸ§¹ Historial de conversaciÃ³n limpiado")

def get_stats(self) -> Dict:
    """Obtiene estadÃ­sticas de uso"""
    return {
        "model": self.model,
        "conversation_exchanges": len(self.conversation_history) // 2,
        "total_tokens_used": self.total_tokens_used,
        "estimated_cost": self._estimate_cost()
    }

def _estimate_cost(self) -> str:
    """Estima el costo aproximado basado en tokens usados"""
    # Precios aproximados por 1K tokens (marzo 2024)
    prices = {
        "gpt-3.5-turbo": 0.002,
        "gpt-4": 0.03,
        "gpt-4-turbo": 0.01,
        "gpt-4o": 0.005
    }
    
    price_per_1k = prices.get(self.model, 0.002)
    estimated_cost = (self.total_tokens_used / 1000) * price_per_1k
    
    return f"${estimated_cost:.4f}"
```

class BurpMCPProxyClient:
â€œâ€â€œCliente MCP que usa el proxy JAR con stdio (como versiÃ³n 4 funcional)â€â€â€

```
def __init__(self, host: str = "127.0.0.1", port: int = 9876):
    self.host = host
    self.port = port
    self.sse_url = f"http://{host}:{port}"
    self.proxy_jar_path = self._find_proxy_jar()
    self.java_path = self._find_java()
    self.process = None
    self.tools = {}
    self.request_counter = 0

def _find_proxy_jar(self) -> str:
    """Encuentra el proxy JAR"""
    home = os.path.expanduser("~")
    possible_paths = [
        f"{home}/.BurpSuite/mcp-proxy/mcp-proxy-all.jar",
        "/home/ron/.BurpSuite/mcp-proxy/mcp-proxy-all.jar",  # Tu ruta especÃ­fica
        "./mcp-proxy-all.jar"
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            logger.info(f"âœ… Proxy JAR encontrado: {path}")
            return path
    
    raise FileNotFoundError("âŒ Proxy JAR no encontrado. ExtrÃ¡elo desde la pestaÃ±a MCP en Burp Suite.")

def _find_java(self) -> str:
    """Encuentra Java"""
    java_home = os.environ.get("JAVA_HOME")
    if java_home:
        java_path = os.path.join(java_home, "bin", "java")
        if os.path.exists(java_path):
            return java_path
    
    # Intentar java en PATH
    try:
        result = subprocess.run(["java", "-version"], capture_output=True, text=True)
        if result.returncode == 0:
            return "java"
    except FileNotFoundError:
        pass
    
    raise Exception("âŒ Java no encontrado. Instala Java o configura JAVA_HOME.")

async def initialize(self) -> bool:
    """Inicializa usando proxy JAR con stdio (como versiÃ³n 4)"""
    try:
        logger.info(f"ğŸš€ Iniciando proxy JAR: {self.proxy_jar_path}")
        logger.info(f"ğŸŒ SSE URL: {self.sse_url}")
        
        # Comando exacto como Claude Desktop
        cmd = [self.java_path, "-jar", self.proxy_jar_path, "--sse-url", self.sse_url]
        
        self.process = subprocess.Popen(
            cmd,
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1
        )
        
        # Esperar inicio
        await asyncio.sleep(3)
        
        if self.process.poll() is not None:
            stderr = self.process.stderr.read()
            logger.error(f"âŒ Error iniciando proxy: {stderr}")
            return False
        
        # Inicializar protocolo MCP
        if await self._initialize_mcp():
            await self._load_tools()
            logger.info(f"âœ… Proxy inicializado con {len(self.tools)} herramientas")
            return True
        else:
            return False
            
    except Exception as e:
        logger.error(f"Error inicializando proxy: {e}")
        return False

async def _initialize_mcp(self) -> bool:
    """Inicializa protocolo MCP via stdio"""
    try:
        message = {
            "jsonrpc": "2.0",
            "id": "init",
            "method": "initialize",
            "params": {
                "protocolVersion": "2024-11-05",
                "capabilities": {"tools": {}},
                "clientInfo": {"name": "BurpMCPClient-ChatGPT", "version": "5.0.0"}
            }
        }
        
        response = await self._send_stdio_request(message)
        return "result" in response or "error" not in response
        
    except Exception as e:
        logger.error(f"Error inicializando MCP: {e}")
        return False

async def _send_stdio_request(self, message: Dict) -> Dict:
    """EnvÃ­a solicitud via stdio (como versiÃ³n 4)"""
    try:
        # Enviar mensaje
        json_msg = json.dumps(message) + "\n"
        self.process.stdin.write(json_msg)
        self.process.stdin.flush()
        
        # Leer respuesta
        response_line = await asyncio.wait_for(
            asyncio.to_thread(self.process.stdout.readline),
            timeout=15.0
        )
        
        if not response_line.strip():
            raise Exception("Respuesta vacÃ­a del proxy")
        
        return json.loads(response_line.strip())
        
    except Exception as e:
        logger.error(f"Error en comunicaciÃ³n stdio: {e}")
        return {"error": str(e)}

async def _load_tools(self):
    """Carga herramientas via stdio"""
    try:
        self.request_counter += 1
        message = {
            "jsonrpc": "2.0",
            "id": str(self.request_counter),
            "method": "tools/list",
            "params": {}
        }
        
        response = await self._send_stdio_request(message)
        
        if "result" in response and "tools" in response["result"]:
            for tool in response["result"]["tools"]:
                self.tools[tool["name"]] = tool
            logger.info(f"ğŸ“‹ Cargadas {len(self.tools)} herramientas via stdio")
            
            # Mostrar herramientas cargadas
            for name in self.tools.keys():
                desc = self.tools[name].get("description", "Sin descripciÃ³n")
                logger.info(f"  ğŸ”§ {name}: {desc[:60]}...")
        else:
            logger.warning("No se pudieron cargar herramientas via stdio")
            await self._load_default_tools()
            
    except Exception as e:
        logger.error(f"Error cargando herramientas: {e}")
        await self._load_default_tools()

async def _load_default_tools(self):
    """Carga herramientas por defecto si stdio falla"""
    default_tools = {
        "send_http1_request": "EnvÃ­a solicitudes HTTP/1.1 personalizadas",
        "send_http2_request": "EnvÃ­a solicitudes HTTP/2 personalizadas", 
        "create_repeater_tab": "Crea nueva pestaÃ±a en Repeater",
        "send_to_intruder": "EnvÃ­a solicitud a Intruder para fuzzing",
        "url_encode": "Codifica cadenas para uso en URLs",
        "url_decode": "Decodifica cadenas codificadas en URL",
        "base64_encode": "Codifica cadenas en Base64",
        "base64_decode": "Decodifica cadenas Base64",
        "generate_random_string": "Genera cadenas aleatorias",
        "get_proxy_http_history": "Obtiene historial HTTP del proxy",
        "get_proxy_http_history_regex": "Busca en historial HTTP con regex",
        "set_proxy_intercept_state": "Activa/desactiva intercepciÃ³n del proxy",
        "get_scanner_issues": "Obtiene issues del scanner (Pro only)",
        "output_project_options": "Exporta configuraciÃ³n del proyecto",
        "output_user_options": "Exporta configuraciÃ³n del usuario"
    }
    
    logger.info("ğŸ“‹ Cargando herramientas por defecto (fallback)")
    for name, desc in default_tools.items():
        self.tools[name] = {"name": name, "description": desc}
        logger.info(f"  ğŸ”§ {name}: {desc}")

async def call_tool(self, tool_name: str, arguments: Dict) -> str:
    """Ejecuta herramienta via stdio"""
    if tool_name not in self.tools:
        available = list(self.tools.keys())
        return f"âŒ Herramienta '{tool_name}' no disponible.\nğŸ“‹ Disponibles: {', '.join(available)}"
    
    try:
        self.request_counter += 1
        message = {
            "jsonrpc": "2.0",
            "id": str(self.request_counter),
            "method": "tools/call",
            "params": {
                "name": tool_name,
                "arguments": arguments
            }
        }
        
        logger.info(f"ğŸ”§ Ejecutando: {tool_name} via stdio")
        response = await self._send_stdio_request(message)
        
        if "error" in response:
            error_details = response["error"]
            if isinstance(error_details, dict):
                error_msg = error_details.get("message", "Error desconocido")
                return f"âŒ Error MCP: {error_msg}"
            else:
                return f"âŒ Error: {str(error_details)}"
        
        if "result" in response:
            result = response["result"]
            
            if "content" in result and result["content"]:
                content = result["content"][0]
                text = content.get("text", str(content))
                return f"âœ… Resultado (stdio):\n{text}"
            
            return f"âœ… Resultado (stdio):\n{str(result)}"
        
        return "âœ… Comando ejecutado (stdio)"
        
    except Exception as e:
        logger.error(f"Error ejecutando {tool_name} via stdio: {e}")
        return f"""âŒ Error ejecutando {tool_name}: {str(e)}
```

ğŸ”§ DIAGNÃ“STICO STDIO:

- Proceso proxy activo: {â€˜âœ…â€™ if self.process and self.process.poll() is None else â€˜âŒâ€™}
- Herramienta: {tool_name}
- Argumentos: {json.dumps(arguments, indent=2)}

ğŸ’¡ SUGERENCIAS:
{self._get_tool_help(tool_name)}â€â€â€

```
def _get_tool_help(self, tool_name: str) -> str:
    """Proporciona ayuda especÃ­fica para cada herramienta"""
    help_messages = {
        "create_repeater_tab": """
```

Para create_repeater_tab necesitas:
{
â€œtabNameâ€: â€œNombre de la pestaÃ±aâ€,
â€œcontentâ€: â€œGET / HTTP/1.1\r\nHost: example.com\r\n\r\nâ€,
â€œtargetHostnameâ€: â€œexample.comâ€,
â€œtargetPortâ€: 443,
â€œusesHttpsâ€: true
}â€â€â€,
â€œsend_http1_requestâ€: â€œâ€â€
Para send_http1_request necesitas:
{
â€œcontentâ€: â€œGET /path HTTP/1.1\r\nHost: example.com\r\n\r\nâ€,
â€œtargetHostnameâ€: â€œexample.comâ€,
â€œtargetPortâ€: 443,
â€œusesHttpsâ€: true
}â€â€â€,
â€œsend_to_intruderâ€: â€œâ€â€
Para send_to_intruder necesitas:
{
â€œtabNameâ€: â€œAttack Nameâ€,
â€œcontentâ€: â€œPOST /login HTTP/1.1\r\nHost: example.com\r\n\r\nuser=admin&pass=Â§passwordÂ§â€,
â€œtargetHostnameâ€: â€œexample.comâ€,
â€œtargetPortâ€: 443,
â€œusesHttpsâ€: true
}â€â€â€,
â€œget_proxy_http_historyâ€: â€œâ€â€
Para get_proxy_http_history necesitas:
{
â€œcountâ€: 10,
â€œoffsetâ€: 0
}â€â€â€,
â€œurl_encodeâ€: â€œâ€â€
Para url_encode necesitas:
{
â€œcontentâ€: â€œtexto a codificarâ€
}â€â€â€,
â€œbase64_encodeâ€: â€œâ€â€
Para base64_encode necesitas:
{
â€œcontentâ€: â€œtexto a codificarâ€
}â€â€â€
}

```
    return help_messages.get(tool_name, f"Consulta la documentaciÃ³n para {tool_name}")

async def test_connection(self) -> Dict[str, Any]:
    """Prueba la conexiÃ³n del proxy stdio"""
    results = {
        "proxy_process": False,
        "stdio_communication": False,
        "tools_loaded": False,
        "error_details": []
    }
    
    # Test 1: Proceso proxy
    if self.process and self.process.poll() is None:
        results["proxy_process"] = True
    else:
        results["error_details"].append("Proceso proxy JAR no estÃ¡ ejecutÃ¡ndose")
    
    # Test 2: ComunicaciÃ³n stdio
    try:
        test_message = {
            "jsonrpc": "2.0",
            "id": "test_stdio",
            "method": "tools/list",
            "params": {}
        }
        
        response = await self._send_stdio_request(test_message)
        results["stdio_communication"] = "result" in response or "tools" in str(response)
        
        if not results["stdio_communication"]:
            results["error_details"].append(f"ComunicaciÃ³n stdio fallÃ³: {response}")
        
    except Exception as e:
        results["error_details"].append(f"Error comunicaciÃ³n stdio: {e}")
    
    # Test 3: Herramientas cargadas
    results["tools_loaded"] = len(self.tools) > 0
    if not results["tools_loaded"]:
        results["error_details"].append("No se cargaron herramientas")
    
    return results

async def close(self):
    """Cierra el proxy"""
    if self.process:
        self.process.terminate()
        await asyncio.sleep(1)
        if self.process.poll() is None:
            self.process.kill()

def get_tools(self) -> Dict[str, str]:
    """Retorna herramientas"""
    return {name: tool.get("description", "Sin descripciÃ³n") 
            for name, tool in self.tools.items()}
```

class BurpSecurityAssistantV5:
â€œâ€â€œAsistente de seguridad V5 con ChatGPT usando proxy JAR stdioâ€â€â€

```
def __init__(self, burp_host="127.0.0.1", burp_port=9876, 
             openai_api_key=None, chatgpt_model="gpt-3.5-turbo"):
    # CAMBIO PRINCIPAL: Usar BurpMCPProxyClient con stdio
    self.burp = BurpMCPProxyClient(burp_host, burp_port)
    self.ai_client = ChatGPTClient(openai_api_key, chatgpt_model)
    self.system_prompt = self._create_system_prompt()
    self.session_start_time = datetime.now()

def _create_system_prompt(self) -> str:
    """Crea el prompt del sistema optimizado para ChatGPT"""
    return """Eres un experto SENIOR en seguridad web y penetration testing usando Burp Suite.
```

IMPORTANTE: Cuando el usuario solicite usar herramientas de Burp Suite, SIEMPRE debes ejecutarlas usando el formato especÃ­fico indicado mÃ¡s abajo.

IDENTIDAD Y EXPERTISE:

- Especialista en OWASP Top 10, tÃ©cnicas de hacking web y anÃ¡lisis de vulnerabilidades
- Experiencia avanzada con Burp Suite Professional y todas sus herramientas
- Conocimiento profundo de protocolos HTTP/HTTPS, tÃ©cnicas de bypass y evasiÃ³n

REGLA CRÃTICA PARA USAR HERRAMIENTAS:
Cuando el usuario mencione cualquier acciÃ³n que requiera una herramienta de Burp Suite, DEBES ejecutarla automÃ¡ticamente usando este formato EXACTO:

EJECUTAR_HERRAMIENTA[nombre_herramienta] {â€œparametroâ€: â€œvalorâ€}

EJEMPLOS OBLIGATORIOS QUE DEBES SEGUIR:

1. Si el usuario dice â€œbase64_encode 123â€ o â€œencode 123 en base64â€, DEBES responder:
   Voy a codificar â€œ123â€ en Base64 usando Burp Suite:
   EJECUTAR_HERRAMIENTA[base64_encode] {â€œcontentâ€: â€œ123â€}
1. Si el usuario dice â€œurl encode testâ€ o â€œcodifica test en URLâ€, DEBES responder:
   Voy a codificar â€œtestâ€ en URL usando Burp Suite:
   EJECUTAR_HERRAMIENTA[url_encode] {â€œcontentâ€: â€œtestâ€}
1. Si el usuario dice â€œcreate repeater tab with example.comâ€, DEBES responder:
   Voy a crear una pestaÃ±a en Repeater para example.com:
   EJECUTAR_HERRAMIENTA[create_repeater_tab] {â€œtabNameâ€: â€œexample.com Testâ€, â€œcontentâ€: â€œGET / HTTP/1.1\r\nHost: example.com\r\nUser-Agent: Mozilla/5.0\r\n\r\nâ€, â€œtargetHostnameâ€: â€œexample.comâ€, â€œtargetPortâ€: 443, â€œusesHttpsâ€: true}
1. Si el usuario dice â€œget proxy historyâ€ o â€œshow me the last 10 requestsâ€, DEBES responder:
   Voy a obtener el historial del proxy:
   EJECUTAR_HERRAMIENTA[get_proxy_http_history] {â€œcountâ€: 10, â€œoffsetâ€: 0}

PARÃMETROS EXACTOS REQUERIDOS:

base64_encode:

- content: string a codificar

url_encode:

- content: string a codificar

create_repeater_tab:

- tabName: â€œNombre descriptivoâ€
- content: â€œGET / HTTP/1.1\r\nHost: hostname\r\n\r\nâ€
- targetHostname: â€œhostnameâ€
- targetPort: 443 (para HTTPS) o 80 (para HTTP)
- usesHttps: true (para HTTPS) o false (para HTTP)

send_http1_request:

- content: â€œREQUEST HTTP COMPLETO con \r\nâ€
- targetHostname: â€œhostnameâ€
- targetPort: nÃºmero
- usesHttps: true/false

get_proxy_http_history:

- count: nÃºmero de entradas
- offset: desde quÃ© posiciÃ³n

DETECCIÃ“N AUTOMÃTICA:
Cuando detectes estas palabras clave en el input del usuario, EJECUTA automÃ¡ticamente la herramienta:

- â€œbase64â€, â€œencodeâ€, â€œdecodeâ€, â€œcodificaâ€, â€œdecodificaâ€ â†’ usar base64_encode/base64_decode/url_encode/url_decode
- â€œrepeaterâ€, â€œtabâ€, â€œcreate tabâ€, â€œnueva pestaÃ±aâ€ â†’ usar create_repeater_tab
- â€œhistoryâ€, â€œhistorialâ€, â€œproxyâ€, â€œrequestsâ€ â†’ usar get_proxy_http_history
- â€œsend requestâ€, â€œhttp requestâ€, â€œsolicitudâ€ â†’ usar send_http1_request
- â€œintruderâ€, â€œattackâ€, â€œbruteforceâ€ â†’ usar send_to_intruder

IMPORTANTE:

- NUNCA escribas cÃ³digo pseudo como base64_encode(â€œ123â€)
- NUNCA expliques sin ejecutar
- SIEMPRE usa el formato EJECUTAR_HERRAMIENTA[nombre] {â€œparamsâ€}
- SIEMPRE incluye una breve explicaciÃ³n antes de ejecutar
- Si no estÃ¡s seguro de los parÃ¡metros, usa valores por defecto sensatos

METODOLOGÃA:

1. Detectar quÃ© herramienta necesita el usuario
1. Explicar brevemente quÃ© vas a hacer
1. Ejecutar la herramienta con el formato correcto
1. Interpretar y explicar el resultado

Responde siempre como un consultor senior que EJECUTA las herramientas inmediatamente cuando se solicitan.â€â€â€

```
async def initialize(self) -> bool:
    """Inicializa el asistente V5"""
    print("ğŸš€ Inicializando Asistente de Seguridad V5 (ChatGPT + stdio)...")
    
    # Conectar con Burp Suite via proxy JAR
    burp_success = await self.burp.initialize()
    if not burp_success:
        print("âŒ No se pudo conectar con Burp Suite via proxy JAR")
        return False
    
    # Verificar ChatGPT
    try:
        test_response = await self.ai_client.chat(
            "Responde solo 'READY' para confirmar conexiÃ³n", 
            "Eres un asistente de prueba. Responde exactamente lo que se te pide."
        )
        if "READY" in test_response.upper():
            print("âœ… ChatGPT conectado correctamente")
            print(f"ğŸ¤– Modelo: {self.ai_client.model}")
        else:
            print("âš ï¸ ChatGPT responde pero puede tener problemas")
    except Exception as e:
        print(f"âŒ No se pudo conectar con ChatGPT: {e}")
        return False
    
    # Actualizar prompt con herramientas disponibles
    tools_info = "\n".join([f"- {name}: {desc}" 
                           for name, desc in self.burp.get_tools().items()])
    self.system_prompt += f"\n\nHERRAMIENTAS DISPONIBLES EN BURP SUITE:\n{tools_info}"
    
    # ENTRENAR A CHATGPT CON EJEMPLOS
    print("ğŸ§  Entrenando ChatGPT con ejemplos de herramientas...")
    await self._train_chatgpt_with_examples()
    
    print(f"ğŸ“Š {len(self.burp.get_tools())} herramientas cargadas via stdio")
    return True

async def _train_chatgpt_with_examples(self):
    """Entrena a ChatGPT con ejemplos de cÃ³mo usar las herramientas"""
    training_examples = [
        {
            "user": "base64_encode test123",
            "assistant": "Voy a codificar 'test123' en Base64 usando Burp Suite:\nEJECUTAR_HERRAMIENTA[base64_encode] {\"content\": \"test123\"}"
        },
        {
            "user": "url encode <script>alert(1)</script>",
            "assistant": "Voy a codificar el script en URL usando Burp Suite:\nEJECUTAR_HERRAMIENTA[url_encode] {\"content\": \"<script>alert(1)</script>\"}"
        },
        {
            "user": "create repeater tab for example.com",
            "assistant": "Voy a crear una pestaÃ±a en Repeater para example.com:\nEJECUTAR_HERRAMIENTA[create_repeater_tab] {\"tabName\": \"example.com Test\", \"content\": \"GET / HTTP/1.1\\r\\nHost: example.com\\r\\nUser-Agent: Mozilla/5.0\\r\\n\\r\\n\", \"targetHostname\": \"example.com\", \"targetPort\": 443, \"usesHttps\": true}"
        }
    ]
    
    # Agregar ejemplos al historial para que ChatGPT aprenda
    for example in training_examples:
        self.ai_client.conversation_history.append({"role": "user", "content": example["user"]})
        self.ai_client.conversation_history.append({"role": "assistant", "content": example["assistant"]})
    
    print("âœ… ChatGPT entrenado con ejemplos de herramientas")

async def process_message(self, user_message: str) -> str:
    """Procesa mensaje del usuario con ChatGPT"""
    try:
        # Obtener respuesta de ChatGPT
        ai_response = await self.ai_client.chat(user_message, self.system_prompt)
        
        # Ejecutar herramientas si se mencionan
        if "EJECUTAR_HERRAMIENTA[" in ai_response:
            ai_response = await self._execute_tools(ai_response)
        
        return ai_response
        
    except Exception as e:
        logger.error(f"Error procesando mensaje: {e}")
        return f"âŒ Error procesando mensaje: {str(e)}"

async def _execute_tools(self, response: str) -> str:
    """Ejecuta herramientas mencionadas en la respuesta de ChatGPT"""
    import re
    
    # Buscar patrones EJECUTAR_HERRAMIENTA[nombre]
    pattern = r'EJECUTAR_HERRAMIENTA\[([^\]]+)\]'
    matches = re.finditer(pattern, response)
    
    for match in matches:
        tool_name = match.group(1).strip()
        
        # Buscar argumentos JSON despuÃ©s del comando
        json_pattern = r'\{[^}]+\}'
        text_after_match = response[match.end():match.end()+500]
        json_match = re.search(json_pattern, text_after_match)
        
        if json_match:
            try:
                arguments = json.loads(json_match.group(0))
            except json.JSONDecodeError as e:
                arguments = {}
                logger.warning(f"Error parsing JSON para {tool_name}: {e}")
        else:
            arguments = {}
        
        # Ejecutar herramienta via stdio
        result = await self.burp.call_tool(tool_name, arguments)
        
        # Reemplazar comando con resultado
        replacement = f"\n\n**ğŸ”§ Ejecutando {tool_name} (stdio):**\n```\n{result}\n```\n"
        response = response.replace(match.group(0), replacement, 1)
    
    return response

async def chat_loop(self):
    """Loop principal de chat V5"""
    print("\n" + "="*70)
    print("ğŸ”’ ASISTENTE DE SEGURIDAD V5 - Burp Suite + ChatGPT (stdio)")
    print("="*70)
    print("Comandos especiales:")
    print("  /tools     - Ver herramientas disponibles")
    print("  /diagnose  - Diagnosticar problemas de conexiÃ³n stdio")
    print("  /stats     - Ver estadÃ­sticas de ChatGPT")
    print("  /clear     - Limpiar historial y re-entrenar")
    print("  /train     - Re-entrenar ChatGPT con ejemplos")
    print("  /model     - Cambiar modelo de ChatGPT")
    print("  /examples  - Ver ejemplos avanzados")
    print("  /save      - Guardar sesiÃ³n")
    print("  /help      - Mostrar ayuda")
    print("  /quit      - Salir")
    print("="*70)
    
    command_history = []
    
    while True:
        try:
            user_input = input("\nğŸ‘¤ TÃº: ").strip()
            
            if user_input.lower() in ['/quit', '/exit']:
                await self._show_session_summary()
                print("ğŸ‘‹ Â¡Hasta luego!")
                break
            
            elif user_input.lower() == '/tools':
                tools = self.burp.get_tools()
                print(f"\nğŸ› ï¸ Herramientas disponibles ({len(tools)}):")
                for name, desc in tools.items():
                    print(f"  ğŸ”§ {name}: {desc}")
                continue
            
            elif user_input.lower() == '/diagnose':
                print("\nğŸ” Ejecutando diagnÃ³stico de conexiÃ³n stdio...")
                diagnosis = await self.burp.test_connection()
                
                print("\nğŸ“Š RESULTADOS DEL DIAGNÃ“STICO (STDIO):")
                print(f"ğŸ”§ Proceso proxy JAR: {'âœ…' if diagnosis['proxy_process'] else 'âŒ'}")
                print(f"ğŸ“¡ ComunicaciÃ³n stdio: {'âœ…' if diagnosis['stdio_communication'] else 'âŒ'}")
                print(f"ğŸ› ï¸ Herramientas cargadas: {'âœ…' if diagnosis['tools_loaded'] else 'âŒ'}")
                
                if diagnosis['error_details']:
                    print("\nâŒ ERRORES DETECTADOS:")
                    for error in diagnosis['error_details']:
                        print(f"  â€¢ {error}")
                    
                    print("\nğŸ”§ SOLUCIONES ESPECÃFICAS PARA STDIO:")
                    print("1. Verificar que el proxy JAR existe:")
                    print(f"   ls -la {self.burp.proxy_jar_path}")
                    print()
                    print("2. Verificar que Burp Suite estÃ© ejecutÃ¡ndose:")
                    print("   ps aux | grep -i burp")
                    print()
                    print("3. Verificar que el servidor SSE estÃ© activo en Burp:")
                    print(f"   curl http://{self.burp.host}:{self.burp.port}")
                    print()
                    print("4. Extraer proxy JAR desde Burp Suite:")
                    print("   - Ve a la pestaÃ±a MCP en Burp Suite")
                    print("   - Click en 'Extract server proxy jar'")
                    print(f"   - Guardar en: {self.burp.proxy_jar_path}")
                    print()
                    print("5. Verificar Java:")
                    print(f"   {self.burp.java_path} -version")
                    print()
                    print("6. Reiniciar manualmente el proxy:")
                    print(f"   {self.burp.java_path} -jar {self.burp.proxy_jar_path} --sse-url {self.burp.sse_url}")
                else:
                    print("\nâœ… ComunicaciÃ³n stdio funcionando correctamente")
                    print(f"ğŸ“‚ Proxy JAR: {self.burp.proxy_jar_path}")
                    print(f"â˜• Java: {self.burp.java_path}")
                    print(f"ğŸŒ SSE URL: {self.burp.sse_url}")
                
                continue
            
            elif user_input.lower() == '/stats':
                stats = self.ai_client.get_stats()
                print(f"\nğŸ“Š EstadÃ­sticas de ChatGPT:")
                print(f"  ğŸ¤– Modelo: {stats['model']}")
                print(f"  ğŸ’¬ Intercambios: {stats['conversation_exchanges']}")
                print(f"  ğŸ¯ Tokens usados: {stats['total_tokens_used']}")
                print(f"  ğŸ’° Costo estimado: {stats['estimated_cost']}")
                continue
            
            elif user_input.lower() == '/clear':
                self.ai_client.clear_history()
                # Re-entrenar despuÃ©s de limpiar
                await self._train_chatgpt_with_examples()
                print("ğŸ§¹ Historial limpiado y ChatGPT re-entrenado con ejemplos")
                continue
            
            elif user_input.lower() == '/train':
                print("ğŸ§  Re-entrenando ChatGPT con ejemplos...")
                await self._train_chatgpt_with_examples()
                print("âœ… ChatGPT re-entrenado correctamente")
                continue
            
            elif user_input.lower() == '/model':
                print("\nğŸ¤– Modelos disponibles:")
                models = ["gpt-3.5-turbo", "gpt-4", "gpt-4-turbo", "gpt-4o"]
                for i, model in enumerate(models, 1):
                    current = " (actual)" if model == self.ai_client.model else ""
                    print(f"  {i}. {model}{current}")
                
                try:
                    choice = int(input("Selecciona modelo (1-4): ")) - 1
                    if 0 <= choice < len(models):
                        self.ai_client.model = models[choice]
                        print(f"âœ… Modelo cambiado a: {models[choice]}")
                    else:
                        print("âŒ OpciÃ³n invÃ¡lida")
                except ValueError:
                    print("âŒ Entrada invÃ¡lida")
                continue
            
            elif user_input.lower() == '/examples':
                print(self._show_advanced_examples())
                continue
            
            elif user_input.lower() == '/save':
                await self._save_session_v5(command_history)
                continue
            
            elif user_input.lower() == '/help':
                print(self._show_help_v5())
                continue
            
            elif not user_input:
                continue
            
            # Agregar a historial
            command_history.append({
                "timestamp": datetime.now().isoformat(),
                "message": user_input
            })
            
            print("\nğŸ¤– Asistente: ", end="", flush=True)
            response = await self.process_message(user_input)
            print(response)
            
        except KeyboardInterrupt:
            print("\n\nğŸ‘‹ Saliendo...")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}")

def _show_advanced_examples(self) -> str:
    """Muestra ejemplos avanzados para ChatGPT"""
    return """
```

ğŸ“ EJEMPLOS AVANZADOS DE SECURITY TESTING:

ğŸ” RECONOCIMIENTO Y ANÃLISIS:
â€¢ â€œAnaliza las Ãºltimas 20 entradas del historial HTTP en busca de endpoints de API REST y evalÃºa su superficie de ataqueâ€
â€¢ â€œIdentifica todos los parÃ¡metros GET y POST Ãºnicos del historial y sugiere vectores de ataque para cada unoâ€
â€¢ â€œExamina los headers de respuesta del historial para identificar tecnologÃ­as, versiones y configuraciones insegurasâ€

âš¡ TESTING DE VULNERABILIDADES ESPECÃFICAS:
â€¢ â€œPrueba SQL injection en el parÃ¡metro â€˜idâ€™ del endpoint /api/users usando tÃ©cnicas de boolean-based blind injectionâ€
â€¢ â€œCrea un payload XSS que bypassee filtros de Content Security Policy para el formulario de comentariosâ€
â€¢ â€œAnaliza el mecanismo de autenticaciÃ³n JWT y busca vulnerabilidades de signature bypassâ€

ğŸ›¡ï¸ EVALUACIÃ“N DE CONTROLES DE SEGURIDAD:
â€¢ â€œEvalÃºa la implementaciÃ³n de CSRF protection en todos los formularios POST encontrados en el historialâ€
â€¢ â€œAnaliza la configuraciÃ³n de cookies de sesiÃ³n y identifica problemas de seguridad (secure, httponly, samesite)â€
â€¢ â€œRevisa la implementaciÃ³n de rate limiting y sugiere tÃ©cnicas de bypassâ€

ğŸ” ANÃLISIS DE LÃ“GICA DE NEGOCIO:
â€¢ â€œIdentifica flujos de autorizaciÃ³n en la aplicaciÃ³n y busca vulnerabilities de privilege escalationâ€
â€¢ â€œAnaliza el proceso de reset de password en busca de race conditions y logic flawsâ€
â€¢ â€œEvalÃºa el manejo de archivos upload y identifica vectores de ataque para file inclusionâ€

ğŸš¨ TESTING AVANZADO:
â€¢ â€œRealiza un anÃ¡lisis completo de CORS configuration y identifica misconfigurations explotablesâ€
â€¢ â€œEvalÃºa la aplicaciÃ³n contra OWASP Top 10 2021 y genera un reporte de hallazgos prioritizadoâ€
â€¢ â€œCrea un plan de testing personalizado basado en las tecnologÃ­as identificadas en el reconocimientoâ€

ğŸ”§ EJEMPLOS CON HERRAMIENTAS ESPECÃFICAS:
â€¢ â€œCrea una pestaÃ±a en Repeater para secure.ally.com puerto 443 con una solicitud GET bÃ¡sicaâ€
â€¢ â€œEnvÃ­a a Intruder una solicitud de login con el usuario â€˜adminâ€™ para hacer bruteforce de passwordâ€
â€¢ â€œEncode en URL el payload: â€™ OR 1=1 UNION SELECT username,password FROM usersâ€“â€
â€œâ€â€

```
async def _save_session_v5(self, command_history):
    """Guarda sesiÃ³n V5 con estadÃ­sticas de ChatGPT"""
    try:
        stats = self.ai_client.get_stats()
        session_data = {
            "version": "5.0-stdio",
            "timestamp": datetime.now().isoformat(),
            "session_duration": str(datetime.now() - self.session_start_time),
            "commands": command_history,
            "burp_tools": list(self.burp.get_tools().keys()),
            "chatgpt_stats": stats,
            "proxy_info": {
                "jar_path": self.burp.proxy_jar_path,
                "java_path": self.burp.java_path,
                "sse_url": self.burp.sse_url,
                "communication_method": "stdio"
            },
            "system_info": {
                "platform": platform.system(),
                "python_version": sys.version,
                "burp_host": self.burp.host,
                "burp_port": self.burp.port
            }
        }
        
        filename = f"burp_chatgpt_v5_session_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(filename, 'w') as f:
            json.dump(session_data, f, indent=2)
        
        print(f"âœ… SesiÃ³n V5 guardada en: {filename}")
        print(f"ğŸ“Š Resumen: {len(command_history)} comandos, {stats['total_tokens_used']} tokens, {stats['estimated_cost']} costo")
        
    except Exception as e:
        print(f"âŒ Error guardando sesiÃ³n: {e}")

async def _show_session_summary(self):
    """Muestra resumen de la sesiÃ³n"""
    stats = self.ai_client.get_stats()
    duration = datetime.now() - self.session_start_time
    
    print("\n" + "="*50)
    print("ğŸ“Š RESUMEN DE SESIÃ“N V5")
    print("="*50)
    print(f"â±ï¸  DuraciÃ³n: {duration}")
    print(f"ğŸ¤– Modelo usado: {stats['model']}")
    print(f"ğŸ’¬ Intercambios: {stats['conversation_exchanges']}")
    print(f"ğŸ¯ Tokens totales: {stats['total_tokens_used']}")
    print(f"ğŸ’° Costo estimado: {stats['estimated_cost']}")
    print(f"ğŸ”§ Herramientas disponibles: {len(self.burp.get_tools())}")
    print(f"ğŸ“¡ MÃ©todo de comunicaciÃ³n: stdio")

def _show_help_v5(self) -> str:
    """Ayuda completa V5"""
    stats = self.ai_client.get_stats()
    return f"""
```

ğŸ“– AYUDA COMPLETA - Asistente de Seguridad V5 (ChatGPT + stdio)

ğŸ¯ NOVEDADES DE LA VERSIÃ“N 5:
âœ… IntegraciÃ³n completa con ChatGPT (GPT-3.5-turbo, GPT-4, GPT-4-turbo)
âœ… ComunicaciÃ³n robusta via proxy JAR con stdio (como versiÃ³n 4)
âœ… AnÃ¡lisis de seguridad con IA de nivel profesional
âœ… Tracking de costos y tokens en tiempo real
âœ… Prompt especializado en penetration testing
âœ… Capacidad de cambio de modelo dinÃ¡mico
âœ… EstadÃ­sticas detalladas de uso
âœ… DiagnÃ³stico especÃ­fico para comunicaciÃ³n stdio

ğŸ”§ CONFIGURACIÃ“N ACTUAL:
â€¢ Burp Suite: Conectado via proxy JAR + stdio
â€¢ ChatGPT: {self.ai_client.model} - {stats[â€˜conversation_exchangesâ€™]} intercambios
â€¢ Herramientas: {len(self.burp.get_tools())} disponibles
â€¢ Proxy JAR: {self.burp.proxy_jar_path}
â€¢ Java: {self.burp.java_path}
â€¢ SSE URL: {self.burp.sse_url}
â€¢ SesiÃ³n iniciada: {self.session_start_time.strftime(â€™%H:%M:%Sâ€™)}

ğŸ’¬ CÃ“MO INTERACTUAR:
â€¢ Habla en lenguaje natural sobre cualquier aspecto de seguridad web
â€¢ ChatGPT identificarÃ¡ automÃ¡ticamente las herramientas necesarias
â€¢ Proporciona contexto tÃ©cnico detallado para mejores anÃ¡lisis
â€¢ Pregunta sobre vulnerabilidades especÃ­ficas, metodologÃ­as, etc.

ğŸ“ CAPACIDADES AVANZADAS DE CHATGPT:
â€¢ AnÃ¡lisis contextual profundo de vulnerabilidades
â€¢ GeneraciÃ³n de payloads especÃ­ficos y personalizados
â€¢ InterpretaciÃ³n inteligente de resultados de herramientas
â€¢ CorrelaciÃ³n de hallazgos entre mÃºltiples requests/responses
â€¢ Sugerencias de tÃ©cnicas de evasiÃ³n y bypass
â€¢ EvaluaciÃ³n de impacto y priorizaciÃ³n de vulnerabilidades

ğŸ› ï¸ HERRAMIENTAS PRINCIPALES (via stdio):
â€¢ send_http1_request: Solicitudes HTTP personalizadas
â€¢ get_proxy_http_history: AnÃ¡lisis de trÃ¡fico histÃ³rico
â€¢ create_repeater_tab: IntegraciÃ³n con Repeater
â€¢ send_to_intruder: Setup de ataques automatizados
â€¢ url_encode/decode: CodificaciÃ³n para bypasses
â€¢ base64_encode/decode: CodificaciÃ³n de payloads

ğŸ’° GESTIÃ“N DE COSTOS:
â€¢ Usa /stats para monitorear gasto en tiempo real
â€¢ GPT-3.5-turbo: ~$0.002/1K tokens (econÃ³mico)
â€¢ GPT-4-turbo: ~$0.01/1K tokens (equilibrado)
â€¢ GPT-4: ~$0.03/1K tokens (mÃ¡xima calidad)

ğŸš€ TIPS PARA MEJORES RESULTADOS:
â€¢ SÃ© especÃ­fico sobre el tipo de vulnerabilidad que buscas
â€¢ Proporciona contexto sobre la aplicaciÃ³n target
â€¢ Menciona tecnologÃ­as conocidas (framework, server, etc.)
â€¢ Pide explicaciones detalladas de tÃ©cnicas complejas
â€¢ Solicita mÃºltiples vectores de ataque para un mismo objetivo

âš ï¸ CONSIDERACIONES DE SEGURIDAD:
â€¢ No envÃ­es datos sensibles reales a ChatGPT
â€¢ Usa datos de prueba o sanitizados para examples
â€¢ Recuerda que ChatGPT almacena conversaciones temporalmente
â€¢ Para mÃ¡xima privacidad, considera usar modelos locales (Ollama)

ğŸ”„ COMANDOS ESPECIALES:
/tools - Ver herramientas de Burp disponibles
/diagnose - DiagnÃ³stico de comunicaciÃ³n stdio
/stats - EstadÃ­sticas de uso y costos de ChatGPT
/model - Cambiar entre modelos de ChatGPT
/clear - Limpiar historial de conversaciÃ³n
/save - Guardar sesiÃ³n completa con estadÃ­sticas

ğŸ”§ VENTAJAS DE LA COMUNICACIÃ“N STDIO:
âœ… MÃ©todo probado y estable (igual que Claude Desktop)
âœ… No depende de endpoints HTTP especÃ­ficos
âœ… ComunicaciÃ³n bidireccional confiable
âœ… Compatible con todas las herramientas MCP de Burp
âœ… Manejo robusto de errores y timeouts
â€œâ€â€

```
async def close(self):
    """Cierra conexiones V5"""
    await self.burp.close()
```

def setup_chatgpt_v5():
â€œâ€â€œConfiguraciÃ³n de ChatGPT para V5â€â€â€
print(â€œğŸ”§ CONFIGURACIÃ“N CHATGPT V5â€)
print(â€=â€ * 50)

```
# Verificar API key existente
api_key = os.getenv("OPENAI_API_KEY")

if api_key:
    # Validar formato de API key
    if api_key.startswith("sk-") and len(api_key) > 20:
        print(f"âœ… API key encontrada: {api_key[:8]}...{api_key[-8:]}")
        return api_key
    else:
        print("âš ï¸ API key encontrada pero formato invÃ¡lido")

print("âŒ API key no configurada o invÃ¡lida")
print("\nğŸ“‹ OPCIONES DE CONFIGURACIÃ“N:")
print("1. Configurar variable de entorno (recomendado)")
print("2. Ingreso directo (temporal)")
print("3. Archivo de configuraciÃ³n")

while True:
    choice = input("\nSelecciona opciÃ³n (1-3): ").strip()
    
    if choice == "1":
        api_key = input("\nğŸ”‘ Ingresa tu API key de OpenAI: ").strip()
        if not api_key.startswith("sk-"):
            print("âŒ Formato de API key invÃ¡lido. Debe empezar con 'sk-'")
            continue
        
        print(f"\nğŸ“ CONFIGURACIÃ“N PERMANENTE:")
        print("Agrega esta lÃ­nea a tu ~/.bashrc, ~/.zshrc o ~/.profile:")
        print(f"export OPENAI_API_KEY='{api_key}'")
        print("\nLuego ejecuta: source ~/.bashrc (o el archivo correspondiente)")
        
        # Configurar temporalmente para esta sesiÃ³n
        os.environ["OPENAI_API_KEY"] = api_key
        return api_key
    
    elif choice == "2":
        api_key = input("\nğŸ”‘ Ingresa tu API key de OpenAI: ").strip()
        if not api_key.startswith("sk-"):
            print("âŒ Formato de API key invÃ¡lido. Debe empezar con 'sk-'")
            continue
        print("âš ï¸ Esta configuraciÃ³n es temporal (solo para esta sesiÃ³n)")
        return api_key
    
    elif choice == "3":
        api_key = input("\nğŸ”‘ Ingresa tu API key de OpenAI: ").strip()
        if not api_key.startswith("sk-"):
            print("âŒ Formato de API key invÃ¡lido. Debe empezar con 'sk-'")
            continue
        
        try:
            config_file = "chatgpt_config.json"
            config_data = {"openai_api_key": api_key}
            with open(config_file, 'w') as f:
                json.dump(config_data, f, indent=2)
            print(f"âœ… ConfiguraciÃ³n guardada en: {config_file}")
            print("âš ï¸ IMPORTANTE: Agrega este archivo a .gitignore para seguridad")
            return api_key
        except Exception as e:
            print(f"âŒ Error guardando configuraciÃ³n: {e}")
            continue
    
    else:
        print("âŒ OpciÃ³n invÃ¡lida. Selecciona 1, 2 o 3.")
```

def load_config_file():
â€œâ€â€œCarga configuraciÃ³n desde archivo si existeâ€â€â€
try:
with open(â€œchatgpt_config.jsonâ€, â€˜râ€™) as f:
config = json.load(f)
return config.get(â€œopenai_api_keyâ€)
except FileNotFoundError:
return None
except Exception as e:
logger.warning(fâ€Error cargando configuraciÃ³n: {e}â€)
return None

def show_model_comparison_v5():
â€œâ€â€œMuestra comparaciÃ³n detallada de modelos ChatGPTâ€â€â€
print(â€\nğŸ¤– COMPARACIÃ“N DE MODELOS CHATGPTâ€)
print(â€=â€ * 60)

```
models = {
    "gpt-3.5-turbo": {
        "Costo": "~$0.002/1K tokens",
        "Velocidad": "Muy rÃ¡pido (1-3 seg)",
        "Calidad": "Buena para tareas generales",
        "Contexto": "16K tokens",
        "Recomendado para": "Uso general, anÃ¡lisis bÃ¡sicos"
    },
    "gpt-4": {
        "Costo": "~$0.03/1K tokens", 
        "Velocidad": "Lento (10-30 seg)",
        "Calidad": "Excelente para anÃ¡lisis complejos",
        "Contexto": "8K tokens",
        "Recomendado para": "AnÃ¡lisis crÃ­ticos, vulnerabilidades complejas"
    },
    "gpt-4-turbo": {
        "Costo": "~$0.01/1K tokens",
        "Velocidad": "Medio (3-8 seg)", 
        "Calidad": "Muy buena, equilibrada",
        "Contexto": "128K tokens",
        "Recomendado para": "Equilibrio perfecto precio/calidad"
    },
    "gpt-4o": {
        "Costo": "~$0.005/1K tokens",
        "Velocidad": "RÃ¡pido (2-5 seg)",
        "Calidad": "Excelente para multimodal",
        "Contexto": "128K tokens", 
        "Recomendado para": "AnÃ¡lisis de imÃ¡genes, docs complejos"
    }
}

for model, specs in models.items():
    print(f"\nğŸ“Š {model.upper()}:")
    for spec, value in specs.items():
        print(f"  {spec}: {value}")

print(f"\nğŸ’¡ RECOMENDACIÃ“N PARA SEGURIDAD:")
print("â€¢ Desarrollo/Testing: gpt-3.5-turbo")
print("â€¢ AnÃ¡lisis profesional: gpt-4-turbo") 
print("â€¢ Casos crÃ­ticos: gpt-4")
```

async def test_chatgpt_connection(api_key: str, model: str = â€œgpt-3.5-turboâ€):
â€œâ€â€œPrueba la conexiÃ³n con ChatGPTâ€â€â€
print(fâ€\nğŸ§ª PROBANDO CONEXIÃ“N CON CHATGPT ({model})â€)
print(â€=â€ * 50)

```
try:
    client = ChatGPTClient(api_key, model)
    
    # Test bÃ¡sico
    print("ğŸ“¡ Enviando mensaje de prueba...")
    response = await client.chat(
        "Responde exactamente 'CONEXION_OK' para confirmar que funciona",
        "Eres un bot de prueba. Responde exactamente lo solicitado."
    )
    
    if "CONEXION_OK" in response:
        print("âœ… ConexiÃ³n exitosa")
        
        # Test de capacidades de seguridad
        print("ğŸ”’ Probando capacidades de seguridad...")
        security_response = await client.chat(
            "Lista 3 vulnerabilidades web comunes en una lÃ­nea separadas por comas",
            "Eres un experto en seguridad web."
        )
        
        print(f"ğŸ›¡ï¸ Respuesta de seguridad: {security_response[:100]}...")
        
        # Mostrar estadÃ­sticas
        stats = client.get_stats()
        print(f"ğŸ“Š Tokens usados: {stats['total_tokens_used']}")
        print(f"ğŸ’° Costo estimado: {stats['estimated_cost']}")
        
        return True
    else:
        print(f"âŒ Respuesta inesperada: {response}")
        return False
        
except Exception as e:
    print(f"âŒ Error en conexiÃ³n: {e}")
    return False
```

async def main():
â€œâ€â€œFunciÃ³n principal V5â€â€â€
print(â€œğŸš€ ASISTENTE DE SEGURIDAD V5 - CHATGPT + STDIO INTEGRATIONâ€)
print(â€=â€ * 70)
print(â€œVersiÃ³n 5.0 - ChatGPT + Proxy JAR con comunicaciÃ³n stdioâ€)
print(â€œMÃ©todo probado y estable igual que Claude Desktopâ€)
print()

```
# Configurar ChatGPT
api_key = load_config_file() or setup_chatgpt_v5()
if not api_key:
    print("âŒ No se pudo configurar ChatGPT")
    return

# Mostrar opciones de modelo
show_model_comparison_v5()
print(f"\nğŸ¤– Modelo por defecto: gpt-3.5-turbo")

change_model = input("Â¿Quieres cambiar el modelo? (y/N): ").strip().lower()
model = "gpt-3.5-turbo"

if change_model == 'y':
    models = ["gpt-3.5-turbo", "gpt-4-turbo", "gpt-4", "gpt-4o"]
    print("\nModelos disponibles:")
    for i, m in enumerate(models, 1):
        print(f"  {i}. {m}")
    
    try:
        choice = int(input("Selecciona (1-4): ")) - 1
        if 0 <= choice < len(models):
            model = models[choice]
            print(f"âœ… Modelo seleccionado: {model}")
        else:
            print("âŒ OpciÃ³n invÃ¡lida, usando gpt-3.5-turbo")
    except ValueError:
        print("âŒ Entrada invÃ¡lida, usando gpt-3.5-turbo")

# Probar conexiÃ³n
if not await test_chatgpt_connection(api_key, model):
    print("âŒ No se pudo establecer conexiÃ³n con ChatGPT")
    return

# Crear e inicializar asistente
assistant = BurpSecurityAssistantV5(openai_api_key=api_key, chatgpt_model=model)

try:
    if await assistant.initialize():
        print(f"\nğŸ‰ Â¡Asistente V5 listo!")
        print(f"ğŸ”§ Burp Suite: Conectado via proxy JAR + stdio")
        print(f"ğŸ¤– ChatGPT: {model}")
        print(f"ğŸ“Š Herramientas: {len(assistant.burp.get_tools())}")
        print(f"ğŸ“‚ Proxy JAR: {assistant.burp.proxy_jar_path}")
        await assistant.chat_loop()
    else:
        print("\nâŒ ERROR DE CONFIGURACIÃ“N")
        print("\nVerifica que:")
        print("1. Burp Suite estÃ© ejecutÃ¡ndose")
        print("2. La extensiÃ³n MCP estÃ© instalada y habilitada") 
        print("3. El proxy JAR estÃ© extraÃ­do y disponible")
        print("4. Java estÃ© instalado y disponible")
        print("5. Tu API key de OpenAI sea vÃ¡lida")
        print("6. Tengas crÃ©ditos disponibles en OpenAI")
        print("7. El servidor SSE estÃ© corriendo en Burp (puerto 9876)")

finally:
    await assistant.close()
```

if **name** == â€œ**main**â€:
try:
asyncio.run(main())
except KeyboardInterrupt:
print(â€\nğŸ‘‹ Programa terminado por el usuarioâ€)
except Exception as e:
print(fâ€\nâŒ Error fatal: {e}â€)
logger.error(fâ€Error fatal: {e}â€)
sys.exit(1)